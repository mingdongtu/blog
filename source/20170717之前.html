<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:20170717之前</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-">类、对象、属性、方法在内存中的分布</h1>
<p>1、静态属性和常量区（）
2、栈（内存使用大小固定的，如标量类型）
3、堆（内存使用大小不确定的，如复合数据类型）
4、代码区域（如函数与方法，类）</p>
<p>如何在内存中查找数据？</p>
<pre><code class="lang-php">class Student{
    public $name;
    public function show(){
        echo &quot;&quot;;
    }
}
$stu1 = new Student;
$stu2 = new Student;
</code></pre>
<p>class 在代码区
new Student;new Student;是一个对象，保存在堆中。
在对象之中，方法是同一个，是调用类之中的方法。
如:stu1,stu2调用的show方法军是调用类之中的方法，并不会实例话两个方法，这个与js的构造函数模式是不一样的。
protected:可以在整个类的继承链上的访问；
过滤的方法：在对象属性赋值的时候，使用方法来操作。而不直接使用 “=”。在类中使用公共的方法来使用。</p>
<h1 id="config-php-">config.php文件解析；</h1>
<blockquote>
<p>功能：定义常量</p>
<ul>
<li>WEB_ROOT:网站根目录；</li>
<li>CONFIG_DIR:配置文件目录；</li>
<li>PROJECT_LIB:库文件总目录（项目之中所用的库文件）；</li>
</ul>
</blockquote>
<p>#froeign key</p>
<ul>
<li>如果一个实体的某个字段指向另一个实体的主键，就称为外键，被指向的实体，称之为主实体（主表），也叫父实体（父表）。</li>
<li>负责指向的实体，称之为从实体（从表），也叫子实体。</li>
<li>作用：约束处于关系内的实体</li>
<li>增加字表记录的时候，是否有与之对应的附表记录。如果主表没有相关的记录，从表就不能插入。</li>
<li>在打数量的情况下，使用外键约束会导致很差的性能。一般都不会使用外键这样的东西，连表连接查询最好都不要使用。</li>
<li>大量数据量时进行表的水平切分，像外键约束、触发器、储存过程这些都是禁区。</li>
<li>数据的完整性是业务的需要，因此得由业务层的应用程序来控制。</li>
<li>外键会导致表结构费城混乱，几乎是动都不能动的，一层套一层的外键约束，在表很多的情况下很可能会导致循环约束。</li>
</ul>
<h1 id="-">数据库主键和外键</h1>
<blockquote>
<p>关系型数据库中的一条记录中有若干个属性，若其中一个属性组（注意是组）能唯一标识一条记录，该属性组就可以成为一个主键。</p>
<table>
    <tr><td>主键</td><td>外键</td><td>索引</td></tr>
    <tr><td>唯一标识一条记录的，不容许为空</td><td>表的外键是另一个表的主键，外键可以有重复的，可以是空值</td><td>该字段没有重复值，但可以有一个空值</td></tr>
    <tr><td>用来保证数据的完整性</td><td>用来和其他表建立联系</td><td>提高查询排序的速度</td></tr>
    <tr><td>主键只能有一个</td><td>一个表可以有很多个外键</td><td>一个表可以有很多个唯一索引</td></tr>
</table>

</blockquote>
<h1 id="-">数据库中主键和外键的设计原则</h1>
<blockquote>
<p>主键和外键是把多个表组织为一个有效的数据库的粘合剂。主键和外键的设计对物理数据库的性能和可用性都有决定性的影响。必须将数据库模式从理论上的逻辑设计模式转换为实际的物理模式。而主键和外键的结构是这个设计过程的症结所在。一旦将所设计的数据库用于了生产环境，就很难对这些键进行修改，所以在开发阶段就设计好主键和外键就是非常必要和值得的。</p>
<p><hr/>
主键：
  关系数据库依赖于主键---它是数据库物理模式的基石。
  主键在物理层面上只有两个用途：</p>
<pre><code>    1. 惟一地标识一行。
    2. 作为一个可以被外键有效引用的对象。
</code></pre><p><hr/><br> 基于以上这两个用途，下面给出了我在设计物理层面的主键时所遵循的一些原则：</p>
</blockquote>
<pre><code>    1. 主键应当是对用户没有意义的。如果用户看到了一个表示多对多关系的连接表中的数据，并抱怨它没有什么用处，那就证明它的主键设计地很好。

    2. 主键应该是单列的，以便提高连接和筛选操作的效率。

    注：使用复合键的人通常有两个理由为自己开脱，而这两个理由都是错误的。其一是主键应当具有实际意义，然而，让主键具有意义只不过是给人为地破坏数据库提供了方便。其二是利用这种方法可以在描述多对多关系的连接表中使用两个外部键来作为主键，我也反对这种做法，理由是：复合主键常常导致不良的外键，即当连接表成为另一个从表的主表，而依据上面的第二种方法成为这个表主键的一部分，然，这个表又有可能再成为其它从表的主表，其主键又有可能成了其它从表主键的一部分，如此传递下去，越靠后的从表，其主键将会包含越多的列了。

    3. 永远也不要更新主键。实际上，因为主键除了惟一地标识一行之外，再没有其他的用途了，所以也就没有理由去对它更新。如果主键需要更新，则说明主键应对用户无意义的原则被违反了。

   注：这项原则对于那些经常需要在数据转换或多数据库合并时进行数据整理的数据并不适用。

    4. 主键不应包含动态变化的数据，如时间戳、创建时间列、修改时间列等。

    5. 主键应当有计算机自动生成。如果由人来对主键的创建进行干预，就会使它带有除了惟一标识一行以外的意义。一旦越过这个界限，就可能产生认为修改主键的动机，这样，这种系统用来链接记录行、管理记录行的关键手段就会落入不了解数据库设计的人的手中。
</code></pre><hr/>

<blockquote>
<p>HTTP 是<em>无状态协议</em>。也就是说当浏览器加载页面，然后转到同一网站的另一页面时，服务器和浏览器都没有任何内在的方法可以认识到，这是同一浏览器访问同一网站。换种说法，Web工作的方式就是在每个HTTP请求中都要包含所有必要的信息，服务器才能满足这个请求。网站并不能记忆使用者从一个页面到下一个页面的喜好。所以我们需要用某种方法在http上建立状态，于是便有了cookie和会话。在H5的新特性中的本地储存，同样可以发挥相同的作用。</p>
<p><p>那么cookie如何工作呢？</P>
服务器发送一点信息，浏览器在一段可配置的时期内保存它。发送那些信息是由服务器来决定：通常只是一个唯一ID号吗，标识特定浏览器，从而维持一个有状态的假象。（不同浏览器的cookie是不能够共享的）</p>
</blockquote>
<h4 id="cookie-">cookie的特点：</h4>
<ul>
<li><p>cookie对用户来说是不加密的<br/>
  服务器向客户端发送的所有cookie都能够被客户端查看，虽然会有签名cookie,可以混淆cookie中的内容，但没有加密安全。</p>
</li>
<li><p>用户可以删除或者警用cookie<br/>
  不管浏览器什么时候发起一个跟cookie管理的请求，只要你盲目地相信cookie中的内容，都有可能受到攻击。要确保cookie不被篡改，需要使用签名cookie。</p>
</li>
<li><p>cookie可以用于攻击<br/>
 xss可用javascript修改cookies中的内容。使用签名的cookie，不管用户秀瑷的还是恶意的javascript修改的，这些篡改都会在签名cookie中留下明显的痕迹，并且还可以 设定 选项指明cookie只能由服务器修改。虽然这样的cookie会受限，但是会更加安全。</p>
</li>
<li><p>如果滥用cookie，用户会注意到<br/>
  如果在用户的电脑上设置了很多cookie，或者保存了很多的数据，这可能会惹恼用户，所以应该避免出现这种情况，尽量把对cookie的使用限制在最小范围内。</p>
</li>
<li><p>如果可以选择，会话要优于cookie<br/>
  大多数情况下，可以用会话维持状态，一般来说这样是明智的。并且会话会更容易，不用担心会滥用用户的存储，而且更安全。</p>
</li>
</ul>
<p>在MVC中，模型是“纯粹”的数据和逻辑。它根本不关心自己跟用户之间的交互。视图将模型传递给用户，而控制器则接受用户的输入，处理模型，选择要显示那些视图。视图模型是保持模型抽象性的办法，同时还能为视图提供有意义的数据。</p>
<h3 id="-">控制器</h3>
<p>控制器负责处理用户交互，并根据用户交互选择恰当的视图来显示。实际上，控制器和路由器之间唯一的区别是控制器一般会把相关功能归组。</p>
<h3 id="-">数据库系统阶段</h3>
<p>文件系统不能适应大数据量、多应用共享数据的根本原因：数据没有集中管理。数据库方法的基本触发点：把数据统一管理、控制，共享使用。
数据与程序的关系：多个程序可以共享一个数据库。数据库的特点：</p>
<ul>
<li>数据高度结构化继承，面向全组织。</li>
<li>数据共享好。可为多个不同用户共同使用</li>
<li>数据冗余少，易扩充</li>
<li>数据和程序独立性高 好处：简化应用程序的编写和维护<ul>
<li>物理独立性：存储结构变，逻辑结果构可以不变，从而应用陈旭也不必改变</li>
<li>逻辑独立性：总体逻辑变，局部逻辑可以不变，从而应用程序的编写也不必改变。</li>
</ul>
</li>
<li>数据控制统一<ul>
<li>安全行控制：防止泄密和破坏</li>
<li>完整性控制：正确、有效、相容</li>
<li>并发控制：多用户并发操作的协调控制</li>
<li>故障恢复：发生故障时，将数据库恢复到正确状态</li>
</ul>
</li>
</ul>
<blockquote>
<p>文件系统和数据库系统的本质区别：</p>
<ul>
<li>内部：数据库的数据是结构化的，有联系；文件系统的各记录无联系；</li>
<li>外部：数据库系统是共享的，文件系统基本上是面向特定用户的。</li>
</ul>
</blockquote>
<h3 id="-">数据模型</h3>
<p>现实世界-（抽象）-&gt;信息世界（便于用户和DB设计人员交流-转换-&gt;机械世界（数据世界）（建立数据模型便于机器实现）</p>
<h4 id="-">概念模型（信息模型）</h4>
<p>把现实世界中的客观对象抽象成的某种信息结构，主要用于数据库设计。<br/>
1、实体与记录</p>
<blockquote>
<p>信息世界</p>
<ul>
<li>实体：客观存在并可相互区分的事物</li>
<li>实体集：性质相同的同类实体的集合</li>
<li>属性：实体具有的某一特性</li>
<li>实体标识符：能将一个实体与其他实体区分开来的一个或一组属性</li>
</ul>
<p>数据世界</p>
<ul>
<li>记录&lt;--&gt;实体(抽象表示)</li>
<li>文件&lt;--&gt;实体集</li>
<li>字段或数据项&lt;--&gt;属性</li>
<li>关键字&lt;--&gt;实体标识符。唯一地标识一个记录，又称码、键</li>
</ul>
</blockquote>
<p>2、型与值
在DBS中，每一个对象广义上讲都有型与值之分：型是对象的结构或特性描述。值是一个具体对象的实例。类似于程序设计语言中数据类型与数据值的概念。通常只说实体、记录，含义根据上下问自明。</p>
<ul>
<li>实体型：对实体固有特性或结构的描述。用实体名及其属性名集合来抽象和刻画。</li>
<li>记录型：记录格式；记录值：一个具体的记录</li>
</ul>
<p>3、实体间的联系</p>
<ul>
<li>实体内部的联系（属性间的联系），反应在数据上就是记录内部数据项目之间的联系</li>
<li>实体之间的联系，反应在数据上就是记录之间的联系。<blockquote>
<p>实体之间的联系可归结为三类：</p>
</blockquote>
</li>
<li>1对1联系（1：1）：两个实体集中的每一个实体之多和另一个实体集合中的一个实体有联系。</li>
<li>1对多联系（1：n）：若实体集合A中的每个实体与实体B中0个或多个实体有联系，而B中每个实体之多与A中的一个实体有联系，则称从A到B为1对多的联系。</li>
<li>多对多联系（m:n）: 两个实体集合中的每一个实体和另一个实体集中0个或多个实体有联系。</li>
</ul>
<p>DBS的核心问题之一：如何表示和处理实体及实体间的联系</p>
<h2 id="-">静态内容</h2>
<p>静态内容是指应用程序不会基于每个请求而去改变的资源。也就是说不会应为请求的改变而改变的部分。多媒体（图片、视频、音频）、css、javascript、二进制下载文件（pdf、压缩文件、安装文件等）</p>
<h3 id="-">静态资源角度的优化</h3>
<p>如何处理静态资源对网站的性能有很大的影响，特别是网站有很多多媒体内容时。在性能上主要考虑两点：减少请求次数和缩减内容的大小。</p>
<ul>
<li>减少http请求次数
 特别对移动端来说，在建立http请求的开销大。可以通过合并资源和浏览器缓存。可以经可能多地将小图片合并到一个子画面中。然后利用css设置背景图片的偏移量和尺寸，只展示相关部分；浏览器缓存会在客户端浏览器中储存通用静态资源。</li>
<li>缩减静态资源
 无损:js，css的压缩，png图片的优化；
 有损：jpeg、视频的压缩等</li>
</ul>
<h3 id="-">面向未来的网站</h3>
<p>将静态资源托管到内容发布网络（CDN)。CDN是专为提供敬爱资源而优化的服务器，它利用特殊的头信息启用浏览器缓存。另外CDN还能基于地理位置进行优化，也就是说听他们可以从地理位置上更接近客户端的服务器发布静态内容。尽管互联网确实非常快，但是乘以所有的用户、所有请求和所有资源，累计起来就快了。这样可以为静态资源创建一个抽象层，让重新定位变得异常容易。</p>
<blockquote>
<p>静态映射，让静态资源可重定位、对缓存友善的策略是映射的概念：在编写HTML时，我们没有必要担心静态资源会放在哪里这种细节。我们要关心的是静态资源的逻辑组织。我们将不太具体的路径，映射到更具体的路径，更进一步讲，我们希望可以随意修改映射。</p>
</blockquote>
<h3 id="-">提交静态资源</h3>
<p>浏览器缓存的响应头：</p>
<ul>
<li>Expires/Cache-control，告诉浏览器一个缓存可以缓存的最长时间。如果资源在缓存中，而且它还没过期，也未被用户清除，浏览器就绝不会发起GET请求，这会提升性能，特别是在移动端上。</li>
<li>Last-Modified/ETa，这个两个标签提供了某种模板变化：如果浏览器需要获取资源，它会在下载之前检查这些标签。还会向服务器发起GET请求，但如果这些响应头返回的值让浏览器觉得资源没变，它就不会继续下载那个文件。Last-Modified可以指定资源最后一次修改的时间。ETag可以是任意字符串，一般是版本字符串或内容的嘻哈值。</li>
</ul>
<h3 id="-">修改静态资源</h3>
<p>缓存极大提升了网站的性能，但也不是没有 代价的。特别是如果你修改了静态资源，客户可能直到浏览器中缓存版本过期后才能见到。结局的方案是子纹法。指纹法只是在资源名上加上某种版本信息。当你更新静态资源后，资源名称会变化，浏览器就知道需要下载这个资源了。除了单个文件的指纹，另外一个流行的方案是资源打包。打包即把所有css整合道一个人类看不懂的文件中，客户端JavaScript也死如此。既然总会创新文件，一般做那些文件指纹 也更容易也更常见。</p>
<h3 id="-">打包和缩小</h3>
<p>打包将多个文件打到一个文件中，从而减少http请求次数。缩小将源码中不必要的东西都去掉。也减少了需要做自问处理的资产数量。</p>
<p>层次模型：用树形结构来表示实体以及实体间联系的模型。
网状模型：用图结构来标识实体以及实体间联系的模型。
关系模型：层次、网状模型基本上是面向专业人员的，使用起来起不方便。那么是否能够寻找一种能面向一般用户的数据模型？？</p>
<blockquote>
<p>定义：用二维表（关系）来描述实体及实体间联系的模型</p>
</blockquote>
<h2 id="-">中间件</h2>
<p>中间件是一种功能的封装方式，具体来说就是封装在程序中处理http请求的功能。从实战上讲，中间件只是一个带有三个参数的函数:一个请求对象、一个响应对象、一个next函数(还有一个4种参数的形式(错误处理中间件)，用来做错误处理)</p>
<blockquote>
<p>中间件是在管道中执行的。在express程序中，通过调用app.use向管道中插入中间件。在express 4.0中，中间件和路由处理器是按它们的接入顺序调用的，顺序更清晰。在管道的最后一个“捕获一切”请求的处理器是常见的做法，由它来处理跟前面其他所有路由都不匹配的请求，这个中间件一般会返回404。传给每个中间件next函数来调用下一个中间件，当不传递next的时候，那个请求就会终止了。</p>
<p>路由处理器（app.net、app.post等，经常被统称为app.verb）可以被看作只处理他特定http谓词（GET 、POST等）的中间件。同样，也可以将中间件看作处理全部http谓词的路由处理器。</p>
</blockquote>
<pre><code class="lang-js"> var app = require(&quot;express&quot;)

 app.use((req,res,next)=&gt;{
     console.log(&quot;\n\nALLWAYS&quot;)
     next()
 })
 app.use((err,req,res,next)=&gt;{
    console.log(&quot;检测到未处理的错误：&quot;+ err.message)
    res.send(&quot;500 - 服务器错误&quot;)
})
</code></pre>
<h2 id="-">与生产相关的问题</h2>
<p>在搭建一个设计好要向外拓展的网站时，最重要的是持久话。如果你习惯管用基于文件的存储做持久化，那么就此打住把。例如web程序要通知前50名获胜者获取奖励，当服务器做了负载平衡，一半请求由一台服务器处理，另一半由另一台服务器处理，一台服务器通知了50个人获胜了，另一台也通知了。这样就是一个重复通知的bug。除非所有的服务器都能访问到那个文件系统，否则不应该用本地文件系统做持久化。不过只读数据就是一个例外。</p>
<h2 id="-">持久化</h2>
<p>所有网站和web应用程序（除了最简单的）都需要某种持久化方式，即某种比易失性内存更持久的数据储存方式，这样当遇到服务器宕机、断电、升级和迁移等情况时数据才能保存下来。</p>
<h3 id="-">文件系统持久化</h3>
<p>实现持久化的一种方式是将数据保存到扁平文件中（“扁平”的意思是文件没有人在的结构，只是一串字节）。nonde通过fs（文件系统）模块实现文件系统持久化。文件系统持久化有一些不足自何处，特别是它的拓展行不好。当你需要不止姨太太服务器以满足流量的需求时，除非所有服务器都能访问一个共享的文件系统，否则就会遇到文件系统持久化的问题。此外，因为扁平文件没有内在结构，定位、排序和过滤数据就变成了应用程序的负担。处于这些原因，应该用数据库而不是文件系统来说数据排序。排序二进制文件是个例外，比如图片、音频文件或视频。尽管很多数据库可以处理这些数据，但极少数能够达到文件系统那种效率（尽管关于二进制文件的信息一般会存在数据库里，以便搜索、排序和过滤）</p>
<h3 id="-">数据库持久化</h3>
<p>两种最流行的NoSQL数据库是文档数据库和键-值数据库。文档数据库善于存储对象，这使得它们非常适合node和javascript。键值数据库如其名所示，及其简单，对于数据模式可以轻松映射到键值对程序来说是很好的选择。MongonDB是文档数据库中的佼佼者，现在也 非常健壮和成熟。</p>
<h2 id="-">路由</h2>
<p>需要解决的问题是如何保持前端框架vue.js或者react.js中的前端路由，与后端路由保持一致性。路由过去是基于文件的，非常简单，但是非常不灵活。首先，先了解下IA的概念，IA是指内容的概念性组织。在考虑路由之前有一个可拓展（但不过于复杂的）IA会为后续工作提供巨大的好处。</p>
<h3 id="-">组织路由</h3>
<p>到目前为止，我们都是在行内写路由处理器的，实际上就是马上在那里定义处理器路由的函数。这对小程序或者原型来说没有问题，但是随着网站的增长，这种方式很快就会变得过于笨重。现在你有20或者30个路由，把它们都放在一个文件中，可能没有问题，如果在三年内有200个路由的话，问题就严重了。不管使用什么方法，都应该给确保有增长的空间。</p>
<blockquote>
<p>以某种方式将相关功能分组，那样不仅可以容易利用共享的功能，而且更容易修改相关的方法。
自动化渲染视图。可以模仿Nginx，只要把html文件放到一个目录中，然后很快你你的网站就能提供它的旧时光，那么有这样想法的不止你一个。如果你的网站有很多内容，但是功能不多，你可能发现，给每个视图添加一个路由是 不必要的麻烦，好在我们可以解决这个麻烦。<br/>
比如你想添加文件views/foo.handlebars,然后它就神奇地通过路由/foo访问了。
```js
var autoViews = {}
var fs = require(&quot;fs&quot;)</p>
</blockquote>
<p>app.use(function(req,res,next){
    var path = req.path.toLowerCase()
    // 检查缓存；如果它在那里，渲染这个视图
    if(autoViews[path]) return res.render(autoViews[path])
    // 如果它不在缓存里，就看有没有视图文件与之匹配
    if(fs.existsSync(__dirname + &quot;/views&quot;+path+&quot;.handlebars&quot;)){
        autoViews[path] = path.replace(/^\//,&quot;&quot;)
        return res.render(autoViews[path])
    }
    // 没有发现视图，转到404处理器
})</p>
<pre><code>
## REST API 和JSON
web服务是一个通用术语，指在任何可以通过http访问的应用程序编程界面(api)。web服务的想法已经出现相当长的时间了，直到不久前，那些实现web服务的技术还是沉闷的、错乱的、过于复杂的。现在任然有使用那些技术的系统。rest，representatial state transfer,rest基本上就是客户端和服务段的无状态连接。rest的正式定义还指出服务可以被缓存，可以被分层（即当你使用一个rest api时候，可能还有其他的rest api在它的下面）。从实用的角度来看，因为http的限制，实际上很难创建出非rest 风格的api。

- API 设计
    - GET /api/attractions
          获取景点列表,以 lat、 lng 和 radius 为查询字符串参数， 返回一个景点列表。
    - GET /api/attractions:id
          根据ID返回一处景点
    - POST /api/attraction (景点的描述使用put，应避免url过长)
          以 lat、 lng、 name、 description 和 email 为请求体添加新的景点。 新添加的景点会进入一个待审批队列。
    - PUT  /api/attraction/:id
          更新一处已有的景点。 参数为景点的 ID、 lat、 lng、 name、 description 和 email。 更新会进入待审批队列
    - DEL /api/attraction/:id
          删除景点。 参数为景点 ID、 email 和 reason。 删除会进入待审批队列。      

- API 错误报告，一般通过http状态码实现，然而在大多数应用程序中，并不是所有事情都可以（或者应该）粗略地划分为“成功”或“失败”。比如说，你用id请求某件东西，但是那个id不存在怎么办？这不是服务器错误：客户端请求了不存在的东西。一般来说，错误可以分为以下几类：
    - 灾难性错误            导致服务器的状态不稳定或不可告知的错误。这种错误一般是未处理异常导致的。从灾难行错误中恢复的唯一办法是重启服务器，理想状态下，所有挂起的请求都会收到响应码500，但如果故障很严重，服务器可能根本无法响应，请求会超时。
    - 可恢复的服务器错误     可恢复错误不需要服务器重启，或其他任何壮烈的动作。这种错误一般是服务器上未预料到的错误条件导致的（比如不可用的数据库连接）。问题可能是暂时的或永久的。这种情况下应该返回响应码500.
    - 客户端错误             客户端错误是客户端犯了错误，一般是参数漏掉了或者参数无效。这时不应该调用500。  

- 跨域资源共享（不同的语言在此方案上有不同的解决方案 php header(&quot;Access-Control-Allow-Origin: *&quot;); ）
如果你发布了一个api，应该很想让其他人能够访问这个api。这会导致跨站http请求。跨站http请求一直是很多攻击的对象，因此受到了同源策略的限制，限制可以从哪儿加载脚本。这使得其他网站不可能使用你的api，所以有了跨域资源共享（CORS）。cors容许你针对个案解除这个限制，甚至容许你列出具体哪些域可以访问这个脚本。cors是通过access-control-allow-origin 响应头实现的。

- 数据存储
```js
var mongoose = require(&quot;mongoose&quot;)

var attraction = mongoose.Schema({
    name:String,
    description:String,
    location:{lat:Number,lng:Number},
    history:{
        event:String,
        notes:String,
        email:String,
        date:Date
    },
    updataId:String,
    approved:Boolean
})
var Attraction = mongoose.model(&quot;Attraction&quot;,attractionSchema)
</code></pre><ul>
<li>用express提供api
```js
app.get(&quot;/api/attractions&quot;,function(req,res){
  Attraction.find({approved:true},function(err,attractions){<pre><code>  if(err) return res.send(500,&quot;Error occurred:database error&quot;)
  res.json(attractions.map(function(v){
      return {
          name:v.name,
          id:v.id,
          description:a.description,
          location:a.location
      }
  }))
</code></pre>  })
})
app.post(&quot;/api/attraction&quot;,function(req,res){
  var a = new Attraction({<pre><code>  name:req.body.name,
  description:req.body.description,
  location:{lat:req.body.lat,lng:req.body.lng},
  history:{
      event:&quot;created&quot;,
      email:req.body.email,
      date:new Date(),
  },
  approved:false
</code></pre>  })
})</li>
</ul>
<p>app.get(&quot;/api/attraction/:id&quot;,function(req,res){
    Attraction.findById(req.params.id,function(err,a){
        if(err) return res.send(500,&quot;Error occurred :database error&quot;)
        res.json({
            name:a.name,
            id:a._id,
            description:a.description,
            location:a.location
        })
    })
})</p>
<pre><code>
- 使用rest插件  npm install --save connect-rest API 不应该跟网站的常规路由冲突（确保你没有创建任何以“/api” 开头的网站路由）。 我建议把 API 路由放在网站路由后面： connect-rest 模块会检查每一个请求， 向请求对象中添加属性， 还会做额外的日志记录。 因此把它放在网站路由后面更好， 但要在 404 处理器
```js
var rest =require(&quot;connect-rest&quot;)
var apiOptions = {
    context:&quot;/api&quot;,
    domain:require(&quot;domain&quot;).create()
}
app.use(rest.rester(apiOptions))

rest.get(&quot;/attractions&quot;,function(req,res,cb){
    Atrraction.find({approved:true},function(err,attractions){
        if(err) return cb({error:&quot;Inernal error.&quot;})
        cb(null,attractions.map(function(v){
            return {
                name:v.name,
                description:v.description,
                location:v.location
            }
        }))
    })
})

rest.post(&quot;/attraction&quot;,function(req,content,cb){
    var a = new Attraction({
        name:req.body.name,
        description:req.body.description,
        location:{lat:req.body.lat,lng:req.body.lng},
        history:{
            event:&quot;created&quot;,
            description:req.body.description,
            location:{
                envent:&quot;created&quot;,
                email:req.body.email,
                date:new Date()
            },
            approved:false
        }
    });
    a.save(function(err,a){
        if(err) return cb({error:&quot;Unable to add attraction.&quot;})
        cb(null,{id:a._id})
    })
})

rest.get(&quot;/attraction/:id&quot;,function(req,content,cb){
    Attraction.findById(req.params.id,function(err,a){
        cb(null,{
            name:attraction.name,
            description:attraction.description,
            location:attraction.location
        })
    })
})
</code></pre><ul>
<li>因为api的实质上是不同与网站的，所以很多人都会选择用子域跟网站其余部分分开。可以使用中间件vhost</li>
</ul>
<h2 id="-">静态内容</h2>
<p>静态内容是指应用程序不会基于每个请求而去改变的资源。一般下面的都是静态内容：</p>
<ul>
<li>多媒体
图片、视频和音频文件。虽然这都是即时生成的，但是并不常见，但是大多数多媒体都是静态的。</li>
<li>CSS
即便使用less、sass或stylus这样的抽象css语言，浏览器需要的还是普通的css</li>
<li>javascript
服务器运行的是javascript并不意味着没有客户端javascript。客户端javascript是静态资源。  </li>
<li>二进制下载文件
这包含所有种类：PDF、压缩文件、安装文件等类似的东西</li>
</ul>
<h3 id="-">性能方面的考虑</h3>
<p>如何处理静态资源对网站的性能有很大影响，特别是网站有很多多媒体内容时。在性能上主要考虑两点：减少请求次数和缩减内容的大小。</p>
<h1 id="demos">demos</h1>
<h2 id="app-js">app.js</h2>
<pre><code class="lang-js">// demo
// 一个简单的路由
/*
var http = require(&quot;http&quot;)
http.createServer((req,res)=&gt;{
    var path = req.url.replace(/\/?(?:\.*)$/,&quot;&quot;).toLowerCase()
    res.writeHead(200,{&quot;Content-Type&quot;:&quot;text/plain&quot;})
    switch (path){
        case &quot;&quot; :
                res.end(&quot;homepage&quot;)
                break
        case &quot;/about&quot;:
                res.end(&quot;About&quot;)        
                break
        default:
                res.end(&quot;Not Found&quot;)                
                break
    }
}).listen(3000)
*/

/*
var http = require(&quot;http&quot;),
    fs = require(&quot;fs&quot;)
function serveStaticFile(res,path,contentType,responseCode){
    if(!responseCode) responseCode = 200
    fs.readFile(__dirname+path,(err,data)=&gt;{
        if(err){
            res.writeHead(500,{&quot;Content-Type&quot;:&quot;text/plain&quot;})
            res.end(&quot;500-Internal Error&quot;)
        }else{
            res.writeHead(responseCode,{&quot;Content-Type&quot;:contentType})
            res.end(data)
        }
    })
}

http.createServer((req,res)=&gt;{
    var path = req.url.replace(/\/?(?:\?.*)?$/,&quot;&quot;).toLowerCase()
    switch(path){
        case &quot;&quot;:
            serveStaticFile(res,&quot;/public/home.html&quot;,&quot;text/html&quot;)
            break

        case &quot;/about&quot;:
            serveStaticFile(res,&quot;/public/about.html&quot;,&quot;text/html&quot;)
            break    

        case &quot;/img/logo.jpg&quot;:
            serveStaticFile(res,&quot;/public/img/logo.jpg&quot;,&quot;image/jpg&quot;)
            break

        default:
            serveStaticFile(res,&quot;/public/notfound.html&quot;,&quot;text/html&quot;,404)
    }
}).listen(3000,()=&gt;{
    console.log(&quot;the server is running at port 3000&quot;)
})
*/

/* express middleware
var app = require(&quot;express&quot;)
app.use((req,res,next)=&gt;{
    console.log(&quot;\n\nALLWAYS&quot;)
    next()
})

app.get(&quot;/a&quot;,(req,res)=&gt;{
    console.log(&quot;/a:router ends&quot;)
    res.send(&quot;a&quot;)
})

app.get(&quot;/a&quot;,(req,res)=&gt;{
    console.log(&quot;/a:never resolves&quot;)
})

app.get(&quot;/b&quot;,(req,res,next)=&gt;{
    console.log(&quot;/b:router still works&quot;)
    next()
})

app.use((req,res,next)=&gt;{
    console.log(&quot;some times&quot;)
    next()
})

app.get(&quot;/b&quot;,(req,res,next)=&gt;{
    console.log(&quot;/b(part 2):抛出错误&quot;)
    throw new Error(&quot;b失败&quot;)
})

app.use(&quot;/b&quot;,(err,req,res,next)=&gt;{
    console.log(&quot;/b 检测到错误并传递&quot;)
})

app.get(&quot;/c&quot;,function(err,req){
    console.log(&quot;/c: 抛出错误&quot;)
    throw new Error(&quot;c失败&quot;)
})

app.use(&quot;/c&quot;,(err,req,res,next)=&gt;{
    console.log(&quot;/c检测到错误但不传递 &quot;)
    next()
})

app.use((err,req,res,next)=&gt;{
    console.log(&quot;检测到未处理的错误：&quot;+ err.message)
    res.send(&quot;500 - 服务器错误&quot;)
})

app.use((req,res)=&gt;{
    console.log(&quot;未处理的路由&quot;)
    res.send(&quot;404 - 未找到&quot;)
})

app.listen(3000,()=&gt;{
    console.log(&quot;监听端口3000&quot;)
})
*/
/*
switch(app.get(&#39;env&#39;)){
    case &#39;development&#39;:
        // 紧凑的、彩色的开发日志
        app.use(require(&#39;morgan&#39;)(&#39;dev&#39;))
        break
    case &quot;production&quot;:
        // express-logger支持日志循环
        app.use(require((&quot;express-logger&quot;){
            path:__dirname + &quot;/log/requests.log&quot;
        }))
        break        
}
*/

// console.log(__dirname,__filename)
// console.log(NODE_ENV)

/*
require(&quot;os&quot;).cpus().forEach(()=&gt;{
    console.log(11)
})
*/

// mongoose连接mongondb
/*
var mongoose = require(&quot;mongoose&quot;)
var opts = {
    server: {
        socketOptions: { keepAlive: 1 }
    }
}
switch (app.get(&#39;env&#39;)) {
    case &#39;development&#39;:
        mongoose.connect(credentials.mongo.development.connectionString, opts);
        break;
    case &#39;production&#39;:
        mongoose.connect(credentials.mongo.production.connectionString, opts);
        break;
    default:
        throw new Error(&#39;Unknown execution environment: &#39; + app.get(&#39;env&#39;));
}

// 创建模式和模型
var mongoose = require(&quot;mongoose&quot;)

var vacationSchema = mongoose.Schema({
    name:Stirng,
    slug:String,
    category:String,
    sku:String,
    description:String,
    priceInCents:Number,
    tags:[Sting],
    inSeason:Boolean,
    requireWaiver:Boolean,
    maximumGuests:Number,
    notes:String,
    packagesSold:Number,
})

vacationSchema.methods.getDisPlayPrice = function(){
    return &quot;$&quot; + (this.priceIncets/100).toFixed(2)
}

var Vaction = mongoose.model(&quot;Vacation&quot;,vacationSchema)
*/

/* express 配置的接口
app.get(&quot;/api/attractions&quot;,function(req,res){
    Attraction.find({approved:true},function(err,attractions){
        if(err) return res.send(500,&quot;Error occurred:database error&quot;)
        res.json(attractions.map(function(v){
            return {
                name:v.name,
                id:v.id,
                description:a.description,
                location:a.location
            }
        }))
    })
})
app.post(&quot;/api/attraction&quot;,function(req,res){
    var a = new Attraction({
        name:req.body.name,
        description:req.body.description,
        location:{lat:req.body.lat,lng:req.body.lng},
        history:{
            event:&quot;created&quot;,
            email:req.body.email,
            date:new Date(),
        },
        approved:false
    })
})

app.get(&quot;/api/attraction/:id&quot;,function(req,res){
    Attraction.findById(req.params.id,function(err,a){
        if(err) return res.send(500,&quot;Error occurred :database error&quot;)
        res.json({
            name:a.name,
            id:a._id,
            description:a.description,
            location:a.location
        })
    })
})
*/

// 使用connect-rest 插件
/*
var rest =require(&quot;connect-rest&quot;)
var apiOptions = {
    context:&quot;/api&quot;,
    domain:require(&quot;domain&quot;).create()
}
app.use(rest.rester(apiOptions))

rest.get(&quot;/attractions&quot;,function(req,res,cb){
    Atrraction.find({approved:true},function(err,attractions){
        if(err) return cb({error:&quot;Inernal error.&quot;})
        cb(null,attractions.map(function(v){
            return {
                name:v.name,
                description:v.description,
                location:v.location
            }
        }))
    })
})

rest.post(&quot;/attraction&quot;,function(req,content,cb){
    var a = new Attraction({
        name:req.body.name,
        description:req.body.description,
        location:{lat:req.body.lat,lng:req.body.lng},
        history:{
            event:&quot;created&quot;,
            description:req.body.description,
            location:{
                envent:&quot;created&quot;,
                email:req.body.email,
                date:new Date()
            },
            approved:false
        }
    });
    a.save(function(err,a){
        if(err) return cb({error:&quot;Unable to add attraction.&quot;})
        cb(null,{id:a._id})
    })
})

rest.get(&quot;/attraction/:id&quot;,function(req,content,cb){
    Attraction.findById(req.params.id,function(err,a){
        cb(null,{
            name:attraction.name,
            description:attraction.description,
            location:attraction.location
        })
    })
})
*/

/*
|id                     | int(10) unsigned       | NO   | PRI | NULL    | auto_increment |
| mid                   | int(10) unsigned       | NO   | UNI | NULL    |                |
| qq                    | varchar(255)           | NO   |     | NULL    |                |
| mobile                | varchar(255)           | NO   |     | NULL    |                |
| salary_ten_minute     | decimal(10,2) unsigned | NO   |     | NULL    |                |
| gift_personal_percent | decimal(10,2) unsigned | NO   |     | NULL    |                |
| gift_sociaty_percent  | decimal(10,2) unsigned | NO   |     | NULL    |                |
| alipay_account        | varchar(255)           | NO   |     | NULL    |                |
| alipay_true_name      | varchar(255)           | NO   |     | NULL    |                |
| true_name             | varchar(255)           | NO   |     | NULL    |                |
| sociaty_id            | int(11)                | NO   |     | NULL    |                |
| last_ti_time          | datetime               | NO   |     | NULL    |                |
| level                 | tinyint(3) unsigned    | NO   |     | NULL    |                |
| earn_coin             | int(10) unsigned       | NO   |     | NULL    |                |
| earn_low_coin         | int(10) unsigned       | NO   |     | NULL    |                |
| dead_user_min         | int(10) unsigned       | NO   |     | NULL    |                |
| dead_user_max         | int(10) unsigned       | NO   |     | NULL    |                |
| note                  | varchar(255)           | NO   |     | NULL    |                |
| add_time              | datetime               | NO   |     | NULL    |                |
| verified              | tinyint(4)             | NO   |     | NULL    |                |
| verify_info           | varchar(255)           | NO   |     | NULL    |                |
| id_card               | varchar(255)           | NO   |     | NULL    |                |
| online_base           | int(10) unsigned       | NO   |     | NULL    |                |
| signed_type           | tinyint(3) unsigned    | NO   |     | NULL    |                |
| agreement             | tinyint(3) unsigned    | NO   |     | NULL    |                |
| location              | varchar(255)           | NO   |     | NULL    |                |
| city                  | varchar(255)           | NO   |     | NULL    |                |
| tags                  | varchar(255)           | NO   |     | NULL    |                |
| content_package_id    | tinyint(4)             | NO   |     | NULL    |                |
| label                 | tinyint(4)             | NO   |     | NULL    |                |
*/
console.log(&quot;hello , world&quot;)

function foo(){
    console.log(&quot;hello,foo&quot;)
    return 100
}

var bar = &quot;This is a pen.&quot;

var http = require(&quot;http&quot;)

var i = foo()

console.log(i)

/**
 *所有的可能触发事件都是一个继承了EventEmitter类的子类的实例对象，在node.js中为EventEmitter类定义了许多方法，所有与对象处理函数的绑定相关
 *与对象的事件处理函数的绑定及解除相关的处理程序均依靠这些方法的调用来执行。
 *
 * Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects
 * (called &quot;emitters&quot;) periodically emit named events that cause Function ojects (&quot;listeners&quot;) to be called.
 *
 * For instance:a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is openedl
 * a stream emits an event whenever data is available to be read.
 *
 * All objects that emit events are instances of the EventEmitter class.These objects expose an eventtEmitter.on() function that allows one
 * or more functions to be attached to named events emitted by the oject.Typically ,event names are camel-cased strings but any valid javascript
 * property key can be used
 *
 * When the EventEmitter oject emits an event ,all of the functions attached to that specific event are called synchronously .Any values return by 
 * the cakked listeners are ignored and will be discarded
 *
 * The following example shows a simple EventEmitter instance with a single listener.The eventEmitter.on() method is used to register listeners 
 * while the eventEmittter.emit() method is used to trigger the event
 *
 * 
 * 
 */

//  const EventEmitter = require(&quot;events&quot;)

//  class MyEmitter extends EventEmitter {}

//  const myEmitter = new MyEmitter()

//  myEmitter.on(&#39;event&#39;,()=&gt;{
//      console.log(&quot;an event occurred&quot;)
//  })

// myEmitter.emit(&#39;event&#39;);

/**
 * Passing arguments and this to listeners
 * The eventEmitter.emit() method allows an arbitrary set of argumens to be passed to the listener function.
 * It is important to keep in mind that when an ordinary listener function is called by the EventEmitter,the standard this keyword is intentionlly set to reference the EventEmitter to which the listener is attached
 * 
 */
// const EventEmitter = require(&quot;events&quot;)
// class MyEmitter extends EventEmitter {}


// const myEmitter = new MyEmitter()

// myEmitter.on(&#39;event&#39;,function(a,b){
//     console.log(a,b,this)
//   //   a b MyEmitter {
//   //     domain: null,
//   //     _events: { event: [Function] },
//   //     _eventsCount: 1,
//   //     _maxListeners: undefined }
// })

// myEmitter.emit(&quot;event&quot;,&quot;a&quot;,&quot;b&quot;) // 向listener传递任意参数

/**
 * Asychronous vs Synchronous
 * The EventListener calls all listeneers synchronously in the order in which they are registered.This is important to ensure the proper
 * sequencing of events and to aviod race conditions or logic errors.When appropriate ,listenr functions can switch to an asynchronous mode
 * of operation using the setImmediate() or process.nextTick() methods
 * 
 */

// const EventEmitter = require(&quot;events&quot;)
// class MyEmitter extends EventEmitter {}

// const myEmitter = new MyEmitter()

// myEmitter.on(&quot;event&quot;,(a,b)=&gt;{
//     setImmediate(()=&gt;{
//         console.log(&quot;this happens asynchronously&quot;)
//     })
// })
// myEmitter.emit(&quot;event&quot;,&quot;a&quot;,&quot;b&quot;)

/**
 * Handling events only once
 * When a listener is registered using the EventEmitter.on() method,that listener will be invoked every timer the named event is emitted
 * Using the evnetEmitter.once() method,it is possible to register a listener that is called at most once for a particular event.Once the
 * event is emitted,the listener is unregistered and then called 
 */
// const EventEmitter = require(&quot;events&quot;)
// class MyEmitter extends EventEmitter{}

// const myEmitter = new MyEmitter()

// version 1.0
// let m = 0
// myEmitter.on(&quot;event&quot;,()=&gt;{
//     console.log(++m)
// })

// myEmitter.emit(&quot;event&quot;)
// myEmitter.emit(&quot;event&quot;)

// version 2.0
// let m = 0
// myEmitter.once(&quot;event&quot;,()=&gt;{
//     console.log(++m)
// })
// myEmitter.emit(&quot;event&quot;)
// myEmitter.emit(&quot;event&quot;)
// myEmitter.emit(&quot;event&quot;)


/**
 * Error Events 
 * When an error occurs within an EventEmitter instance,the typical action is for an &quot;error&quot; event to be emitted .These are treated as special cases within node.js
 * If an EventEmitter does not have at least one listener registered for the &quot;error&quot; event,and an &quot;error&quot; event is emitted,the error is thrown,a stack trace is printed
 * and the node.js process exits  
 */

// const EventEmitter = require(&quot;events&quot;)
// class MyEmitter extends EventEmitter {}

// const myEmitter = new MyEmitter()

// myEmitter.emit(&quot;error&quot;,new Error(&quot;whoops!&quot;))


// insert into moderator_addition values(
//     &#39;&#39;,
//     2336,
//     233334,
//     2345434534,
//     21,
//     0.2,
//      0.05,
//      12,
//      9,
//      &#39;2016-05-04&#39;,
//      &#39;15&#39;,
//      &#39;23442&#39;,
//      &#39;2342&#39;,
//      &#39;50&#39;,
//      &#39;500&#39;,
//      &#39;&#39;,
//      &#39;2016-06-01 12:00&#39;,
//      &#39;sdfsa&#39;,
//      &#39;硕大的&#39;,
//      &#39;1&#39;,
//      &#39;sdf&#39;,
//      &#39;2342&#39;,
//      &#39;0&#39;,
//      &#39;0&#39;
// );

// 以http模块为例子
// 给同一个事件绑定一个处理函数
// var http = require(&quot;http&quot;)
// var server = http.createServer()
// server.on(&quot;request&quot;,function(req,res){
//     if(req.url !== &quot;/favicon.ico&quot;){
//         console.log(req.url)
//     }
//     res.end(&quot;res edded&quot;)
// }).listen(3000,&quot;127.0.0.1&quot;)
// 


// var http = require(&quot;http&quot;)
// var server = http.createServer()

// server.on(&quot;request&quot;,(req,res)=&gt;{
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(&quot;the server has received msg&quot;)
//     }

// })

// server.on(&quot;request&quot;,(req,res)=&gt;{
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(req.url)
//     }
//     res.end(&quot;end2&quot;)
// })

// server.addListener(&quot;request&quot;,(req,res)=&gt;{
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(&quot;the server shou dao xiaoxi lalala~&quot;)
//     }
//     // res.end(&quot;end3&quot;)
// })

// server.listen(3000,&quot;127.0.0.1&quot;)
// 

// var http = require(&quot;http&quot;)
// var server = http.createServer()

// var testFunction = function(req,res){
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(&quot;发送请求完毕&quot;)
//     }
// }

// server.on(&quot;request&quot;,function(req,res){
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(&quot;接受客户请求&quot;)
//     }
// })

// server.on(&quot;request&quot;,function(req,res){
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(req.url)
//     }
//     res.end()
// })

// server.on(&quot;request&quot;,testFunction) // 解除绑定之后并不能看到响应的数据

// server.removeListener(&quot;request&quot;, testFunction)

// server.removeAllListeners(&quot;request&quot;)

// server.on(&quot;request&quot;,(req,res)=&gt;{
//     console.log(req.url)
//     res.end(&quot;balabala&quot;)
// })


// server.listen(3000,&quot;127.0.0.1&quot;) 


// var http = require(&quot;http&quot;)
// var events = require(&quot;events&quot;)
// var server = http.createServer()

// server.on(&quot;request&quot;,(req,res)=&gt;{
//     if(req.url !== &quot;/favicon.icon&quot;){
//         console.log(req.url)
//     }
//     res.end()
// })

// server.on(&quot;foo&quot;,(arg1,arg2,arg3)=&gt;{
//     console.log(&quot;自定义的事件被触发&quot;)
//     console.log(arg1,arg2,arg3)
// })

// console.log(&quot;先执行同步的么？&quot;)

// server.emit(&quot;foo&quot;,&quot;自定义参数1&quot;,&quot;自定义参数2&quot;,&quot;自定义参数3&quot;)

// server.listen(3000,&quot;127.0.0.1&quot;)

// console.log(events.EventEmitter.listenerCount(server,&quot;request&quot;))

var http = require(&quot;http&quot;)
var server = http.createServer()

server.on(&quot;removeListener&quot;,(e,f)=&gt;{
    console.log(&quot;对&quot;+e+ &quot;事件取消事件处理函数&quot;)
    console.log(f)
})

server.on(&quot;newListener&quot;,(e,f)=&gt;{
    console.log(&quot;对&quot;+e+&quot;事件添加事件处理函数&quot;)
    console.log(f)
})

var testFunction = function(req,res){
    if(req.url !== &quot;favicon.ico&quot;){
         console.log(&quot;消息发送完毕&quot;)
    }
}    

server.on(&quot;request&quot;,(req,res)=&gt;{
    if(req.url !== &quot;favicon.ico&quot;){
        console.log(&quot;接收到客户端请求&quot;)
    }
})

server.on(&quot;request&quot;,(req,res)=&gt;{
    if(req.url !== &quot;favicon.ico&quot;){
        console.log(req.url)
    }
    res.end()
})

server.on(&quot;requst&quot;,testFunction)

server.removeListener(&quot;request&quot;,testFunction)

server.listen(3000,&quot;127.0.0.1&quot;)

/**
 * 事件循环机制
 * 在nodeJS之中，采用的是非阻塞型I/O机制，这意味着所有要求应用程序所进行的处理，如http请求，数据库查询，文件的输入/输出等，都不会在处理结束之前阻碍其他处理的进行，也就是说，
 * 这些处理都是独立进行的，当处理结束时，会触发一个回调函数，也就是说,在nodeJS中我们所要编写的是各种I/O事件的回调函数中的处理
 * 在回调函数的执行过程之中，调用其它的回调函数时，在该回调处理完成之后，转而继续执行原回调函数。这种环状处理机制，在node.js中称为事件环机制。
 */
</code></pre>
<h2 id="debug-js">debug.js</h2>
<pre><code class="lang-js">console.log(&quot;hello , world&quot;)

function foo(){
    console.log(&quot;hello,foo&quot;)
    return 100
}

var bar = &quot;This is a pen.&quot;

var http = require(&quot;http&quot;)

var i = foo()

console.log(i)
</code></pre>
<h2 id="event-js">event.js</h2>
<pre><code class="lang-js">/**
 *所有的可能触发事件都是一个继承了EventEmitter类的子类的实例对象，在node.js中为EventEmitter类定义了许多方法，所有与对象处理函数的绑定相关
 *与对象的事件处理函数的绑定及解除相关的处理程序均依靠这些方法的调用来执行。
 *
 * Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects
 * (called &quot;emitters&quot;) periodically emit named events that cause Function ojects (&quot;listeners&quot;) to be called.
 *
 * For instance:a net.Server object emits an event each time a peer connects to it; a fs.ReadStream emits an event when the file is openedl
 * a stream emits an event whenever data is available to be read.
 *
 * All objects that emit events are instances of the EventEmitter class.These objects expose an eventtEmitter.on() function that allows one
 * or more functions to be attached to named events emitted by the oject.Typically ,event names are camel-cased strings but any valid javascript
 * property key can be used
 *
 * When the EventEmitter oject emits an event ,all of the functions attached to that specific event are called synchronously .Any values return by 
 * the cakked listeners are ignored and will be discarded
 *
 * The following example shows a simple EventEmitter instance with a single listener.The eventEmitter.on() method is used to register listeners 
 * while the eventEmittter.emit() method is used to trigger the event
 *
 * 
 * 
 */

//  const EventEmitter = require(&quot;events&quot;)

//  class MyEmitter extends EventEmitter {}

//  const myEmitter = new MyEmitter()

//  myEmitter.on(&#39;event&#39;,()=&gt;{
//      console.log(&quot;an event occurred&quot;)
//  })

// myEmitter.emit(&#39;event&#39;);

/**
 * Passing arguments and this to listeners
 * The eventEmitter.emit() method allows an arbitrary set of argumens to be passed to the listener function.
 * It is important to keep in mind that when an ordinary listener function is called by the EventEmitter,the standard this keyword is intentionlly set to reference the EventEmitter to which the listener is attached
 * 
 */
// const EventEmitter = require(&quot;events&quot;)
// class MyEmitter extends EventEmitter {}


// const myEmitter = new MyEmitter()

// myEmitter.on(&#39;event&#39;,function(a,b){
//     console.log(a,b,this)
//   //   a b MyEmitter {
//   //     domain: null,
//   //     _events: { event: [Function] },
//   //     _eventsCount: 1,
//   //     _maxListeners: undefined }
// })

// myEmitter.emit(&quot;event&quot;,&quot;a&quot;,&quot;b&quot;) // 向listener传递任意参数

/**
 * Asychronous vs Synchronous
 * The EventListener calls all listeneers synchronously in the order in which they are registered.This is important to ensure the proper
 * sequencing of events and to aviod race conditions or logic errors.When appropriate ,listenr functions can switch to an asynchronous mode
 * of operation using the setImmediate() or process.nextTick() methods
 * 
 */

// const EventEmitter = require(&quot;events&quot;)
// class MyEmitter extends EventEmitter {}

// const myEmitter = new MyEmitter()

// myEmitter.on(&quot;event&quot;,(a,b)=&gt;{
//     setImmediate(()=&gt;{
//         console.log(&quot;this happens asynchronously&quot;)
//     })
// })
// myEmitter.emit(&quot;event&quot;,&quot;a&quot;,&quot;b&quot;)

/**
 * Handling events only once
 * When a listener is registered using the EventEmitter.on() method,that listener will be invoked every timer the named event is emitted
 * Using the evnetEmitter.once() method,it is possible to register a listener that is called at most once for a particular event.Once the
 * event is emitted,the listener is unregistered and then called 
 */
// const EventEmitter = require(&quot;events&quot;)
// class MyEmitter extends EventEmitter{}

// const myEmitter = new MyEmitter()

// version 1.0
// let m = 0
// myEmitter.on(&quot;event&quot;,()=&gt;{
//     console.log(++m)
// })

// myEmitter.emit(&quot;event&quot;)
// myEmitter.emit(&quot;event&quot;)

// version 2.0
// let m = 0
// myEmitter.once(&quot;event&quot;,()=&gt;{
//     console.log(++m)
// })
// myEmitter.emit(&quot;event&quot;)
// myEmitter.emit(&quot;event&quot;)
// myEmitter.emit(&quot;event&quot;)


/**
 * Error Events 
 * When an error occurs within an EventEmitter instance,the typical action is for an &quot;error&quot; event to be emitted .These are treated as special cases within node.js
 * If an EventEmitter does not have at least one listener registered for the &quot;error&quot; event,and an &quot;error&quot; event is emitted,the error is thrown,a stack trace is printed
 * and the node.js process exits  
 */

// const EventEmitter = require(&quot;events&quot;)
// class MyEmitter extends EventEmitter {}

// const myEmitter = new MyEmitter()

// myEmitter.emit(&quot;error&quot;,new Error(&quot;whoops!&quot;))


// insert into moderator_addition values(
//     &#39;&#39;,
//     2336,
//     233334,
//     2345434534,
//     21,
//     0.2,
//      0.05,
//      12,
//      9,
//      &#39;2016-05-04&#39;,
//      &#39;15&#39;,
//      &#39;23442&#39;,
//      &#39;2342&#39;,
//      &#39;50&#39;,
//      &#39;500&#39;,
//      &#39;&#39;,
//      &#39;2016-06-01 12:00&#39;,
//      &#39;sdfsa&#39;,
//      &#39;硕大的&#39;,
//      &#39;1&#39;,
//      &#39;sdf&#39;,
//      &#39;2342&#39;,
//      &#39;0&#39;,
//      &#39;0&#39;
// );

// 以http模块为例子
// 给同一个事件绑定一个处理函数
// var http = require(&quot;http&quot;)
// var server = http.createServer()
// server.on(&quot;request&quot;,function(req,res){
//     if(req.url !== &quot;/favicon.ico&quot;){
//         console.log(req.url)
//     }
//     res.end(&quot;res edded&quot;)
// }).listen(3000,&quot;127.0.0.1&quot;)
// 


// var http = require(&quot;http&quot;)
// var server = http.createServer()

// server.on(&quot;request&quot;,(req,res)=&gt;{
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(&quot;the server has received msg&quot;)
//     }

// })

// server.on(&quot;request&quot;,(req,res)=&gt;{
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(req.url)
//     }
//     res.end(&quot;end2&quot;)
// })

// server.addListener(&quot;request&quot;,(req,res)=&gt;{
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(&quot;the server shou dao xiaoxi lalala~&quot;)
//     }
//     // res.end(&quot;end3&quot;)
// })

// server.listen(3000,&quot;127.0.0.1&quot;)
// 

// var http = require(&quot;http&quot;)
// var server = http.createServer()

// var testFunction = function(req,res){
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(&quot;发送请求完毕&quot;)
//     }
// }

// server.on(&quot;request&quot;,function(req,res){
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(&quot;接受客户请求&quot;)
//     }
// })

// server.on(&quot;request&quot;,function(req,res){
//     if(req.url !== &quot;favicon.ico&quot;){
//         console.log(req.url)
//     }
//     res.end()
// })

// server.on(&quot;request&quot;,testFunction) // 解除绑定之后并不能看到响应的数据

// server.removeListener(&quot;request&quot;, testFunction)

// server.removeAllListeners(&quot;request&quot;)

// server.on(&quot;request&quot;,(req,res)=&gt;{
//     console.log(req.url)
//     res.end(&quot;balabala&quot;)
// })


// server.listen(3000,&quot;127.0.0.1&quot;) 


// var http = require(&quot;http&quot;)
// var events = require(&quot;events&quot;)
// var server = http.createServer()

// server.on(&quot;request&quot;,(req,res)=&gt;{
//     if(req.url !== &quot;/favicon.icon&quot;){
//         console.log(req.url)
//     }
//     res.end()
// })

// server.on(&quot;foo&quot;,(arg1,arg2,arg3)=&gt;{
//     console.log(&quot;自定义的事件被触发&quot;)
//     console.log(arg1,arg2,arg3)
// })

// console.log(&quot;先执行同步的么？&quot;)

// server.emit(&quot;foo&quot;,&quot;自定义参数1&quot;,&quot;自定义参数2&quot;,&quot;自定义参数3&quot;)

// server.listen(3000,&quot;127.0.0.1&quot;)

// console.log(events.EventEmitter.listenerCount(server,&quot;request&quot;))

var http = require(&quot;http&quot;)
var server = http.createServer()

server.on(&quot;removeListener&quot;,(e,f)=&gt;{
    console.log(&quot;对&quot;+e+ &quot;事件取消事件处理函数&quot;)
    console.log(f)
})

server.on(&quot;newListener&quot;,(e,f)=&gt;{
    console.log(&quot;对&quot;+e+&quot;事件添加事件处理函数&quot;)
    console.log(f)
})

var testFunction = function(req,res){
    if(req.url !== &quot;favicon.ico&quot;){
         console.log(&quot;消息发送完毕&quot;)
    }
}    

server.on(&quot;request&quot;,(req,res)=&gt;{
    if(req.url !== &quot;favicon.ico&quot;){
        console.log(&quot;接收到客户端请求&quot;)
    }
})

server.on(&quot;request&quot;,(req,res)=&gt;{
    if(req.url !== &quot;favicon.ico&quot;){
        console.log(req.url)
    }
    res.end()
})

server.on(&quot;requst&quot;,testFunction)

server.removeListener(&quot;request&quot;,testFunction)

server.listen(3000,&quot;127.0.0.1&quot;)

/**
 * 事件循环机制
 * 在nodeJS之中，采用的是非阻塞型I/O机制，这意味着所有要求应用程序所进行的处理，如http请求，数据库查询，文件的输入/输出等，都不会在处理结束之前阻碍其他处理的进行，也就是说，
 * 这些处理都是独立进行的，当处理结束时，会触发一个回调函数，也就是说,在nodeJS中我们所要编写的是各种I/O事件的回调函数中的处理
 * 在回调函数的执行过程之中，调用其它的回调函数时，在该回调处理完成之后，转而继续执行原回调函数。这种环状处理机制，在node.js中称为事件环机制。
 */
</code></pre>
<h2 id="fun-js">fun.js</h2>
<pre><code class="lang-js">
// var start = new Date();

// var end = new Date();

// if(end - start &gt;= 10*1000){
//     str +=  &quot;测试字符串&quot;;
// }


var start = (new Date()).getTime();
var str = &quot;&quot;;
test()
function test() {
    for (var i = 0; i &lt; 100; i++) {
        str += &quot;测试字符串测试字符串测试字符串测试字符串测试字符串测试字符串测试字符串&quot;;
    }
    if ((new Date()).getTime() - start &gt;= 10 * 1000) {
        return;
    }
    test()
}

console.log((new Date()).getTime() - start.getTime())

function sleep(numberMillis) {
    var now = new Date();
    var exitTime = now.getTime() + numberMillis;
    while (true) {
        now = new Date();
        if (now.getTime() &gt; exitTime)
            return;
    }
}

sleep(1000)
console.log(132)
</code></pre>
<h3 id="github-js">github.js</h3>
<pre><code class="lang-js">var fs = require(&#39;fs&#39;),
    markdown = require( &quot;markdown&quot; ).markdown,
    fileContent;

// 读入 Markdown 源文件
// fileContent = fs.readFileSync(&#39;20170717.md&#39;, &#39;utf8&#39;);
var filePath = &#39;./20170717.md&#39;;
var template = &#39;./template.html&#39;;
fs.readFile(filePath,&#39;utf8&#39;,(err,data)=&gt;{
    if(err) throw err;
    var content = markdown.toHTML(data);
    // console.log(content);
    // content.replace()
    fs.readFile(filePath,&#39;utf8&#39;,(err,data)=&gt;{
        if(err) throw err;
        var template = data;
        console.log(template);
    })
})
</code></pre>
<h2 id="http-js">http.js</h2>
<pre><code class="lang-js">/**
 * http.Agent + http.ClientRequest + http.Server + http.ServerResponse + http.IncomingMessage ...
 *
 * HTTP 
 * The HTTP interfaces in node.js are designed to support many features of the protocol which have been traditionally difficult to use.
 * In particular,large,possibly chunk -encoded,messages.The interface is carefully to never buffer entire requests or reponses -- the user is able to stream data.
 * 
 */   

/**
 * Class:http.Server
 * This class inherits from net.Server and has the following additional events
 * require(&quot;http&quot;).createServer().on(&quot;request&quot;,(req,res)=&gt;{})
 * req: http.IncomingMessage ,res: http.ServerResponse
 * 
 */ 

// var http = require(&quot;http&quot;)
// var server = http.createServer((req,res)=&gt;{
//     // 
//     console.log(req.url)
// }).listen(3000,&quot;127.0.0.1&quot;)
// server.on(&quot;listening&quot;,()=&gt;{
//     console.log(&quot;服务器端开始监听&quot;)
//     server.close()
// })
// server.on(&quot;close&quot;,()=&gt;{
//     console.log(&quot;服务器已经关闭&quot;)
// })

// var http = require(&quot;http&quot;)
// var server = http.createServer((req,res)=&gt;{
//     res.end()
// }).listen(3000,&quot;127.0.0.1&quot;)

// server.setTimeout(6*1000,function(socket){
//     console.log(&quot;服务器超时&quot;)
//     console.log(socket)
// })

// var http = require(&quot;http&quot;)
// var fs = require(&quot;fs&quot;)
// var server = http.createServer((req,res)=&gt;{
//     if(req.url !== &quot;/favicon.ico&quot;){
//         var out = fs.createWriteStream(&quot;./request.log&quot;)
//         out.write(&quot;客户端请求所用的方法为：&quot;+ req.method +&quot;\r\n&quot;)
//         out.write(&quot;客户端请求所用url字符串为: &quot;+ req.url + &quot;\r\n&quot;)
//         out.write(&quot;客户端请求头对象为：&quot;+JSON.stringify(req.headers) +&quot;\r\n&quot;)
//         out.end(&quot;客户端请求所用的版本为：&quot;+req.httpVersion)
//     }
//     res.end()
// }).listen(3000,&quot;127.0.0.1&quot;)

// var http = require(&quot;http&quot;)
// var fs = require(&quot;fs&quot;)
// http.createServer((req,res)=&gt;{
//     res.writeHead(200,{&#39;Content-Type&#39;:&#39;text/html&#39;,&quot;charset&quot;:&quot;utf-8&quot;})
//     if(req.url !== &quot;/favicon.ico&quot;){
//         req.on(&quot;data&quot;,(data)=&gt;{
//             console.log(&quot;服务器端接受到数据：&quot;+ decodeURIComponent(data))
//         })
//         req.on(&quot;end&quot;,()=&gt;{
//             console.log(&quot;客户端请求数据已全部接受完毕&quot;)
//         })
//     }
//     res.end(&quot;数据已经发送!&quot;)
// }).listen(3000,&quot;127.0.0.1&quot;)

// 在响应头之中设置，access-controll-allow-origin:&quot;http://localhost&quot;
// var num = 0
// var http = require(&quot;http&quot;)
// var server = http.createServer((req,res)=&gt;{
//     if(req.url !== &quot;/favicon.ico&quot;){
//         // res.writeHead(200,{
//         //     &quot;Content-Type&quot;:&quot;text/plain&quot;,
//         //     &quot;Access-Control-Allow-Origin&quot;:&quot;http://127.0.0.1&quot;
//         // })
//         res.setHeader(&quot;Content-Type&quot;,&quot;text/plain&quot;)
//         res.setHeader(&quot;Access-Control-Allow-origin&quot;,&quot;*&quot;)
//         res.write(&quot;你好&quot;)   
//         console.log(&quot;收到请求了&quot; + num +&quot;次&quot;)  
//         num++               
//     }
//     res.end()

// }).listen(3000,&quot;127.0.0.1&quot;)

// var http = require(&quot;http&quot;)
// var server = http.createServer((req,res)=&gt;{
//     if(req.url !== &quot;/favicon.ico&quot;){
//         if(res.headersSent) console.log(&quot;相应头已发送&quot;)
//         else console.log(&quot;响应头未发送&quot;)

//         res.writeHead(200,{&quot;Content-Type&quot;:&quot;text/html&quot;})

//         if(res.headersSent) console.log(&quot;相应头已发送&quot;)
//         else console.log(&quot;响应头未发送&quot;)

//         res.write(&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#39;utf-8&#39;/&gt;&lt;/head&gt;&quot;)
//         res.write(&quot;你好&quot;)
//     }
//     res.end()
// }).listen(3000,&quot;127.0.0.1&quot;)

// const http = require(&quot;http&quot;)
// var server = http.createServer((req,res)=&gt;{
//     if(req.url !== &quot;/favicon.ico&quot;){
//         res.setHeader(&quot;Content-Type&quot;,&quot;text/html&quot;)
//         if(res.headersSent) console.log(&quot;相应头已发送&quot;)
//         else console.log(&quot;响应头未发送&quot;)
//         res.setHeader(&quot;Trailer&quot;,&quot;Content-MD5&quot;)
//         // res.writeHead(200,{&quot;Content-Type&quot;:&quot;text/html&quot;})

//         res.sendDate = false;
//         res.write(&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#39;utf-8&#39;/&gt;&lt;/head&gt;&quot;)

//         if(res.headersSent) console.log(&quot;相应头已发送&quot;)
//         else console.log(&quot;响应头未发送&quot;)

//         res.write(&quot;你好&quot;)
//     }
//     res.end()
// }).listen(3000,&quot;127.0.0.1&quot;)

// var http = require(&quot;http&quot;)
// var fs = require(&quot;fs&quot;)
// var server = http.createServer((req,res)=&gt;{
//     if(req.url !== &quot;/favicon.ico&quot;){
//         res.write(&#39;&lt;meta charset=&quot;UTF-8&quot; /&gt;&#39;)
//         fs.readFile(&quot;./event.js&quot;,(err,data)=&gt;{
//             if(err) console.log(&quot;读取文件时候发生错误&quot;)
//             else{
//                 var flag = res.write(data)
//                 res.end()
//                 console.log(flag)
//             }
//         })

//     }
// }).listen(3000,&quot;127.0.0.1&quot;)

// var http = require(&quot;http&quot;)
// var server = http.createServer((req,res)=&gt;{
//     if(req.url !== &quot;/favicon.ico&quot;){
//         res.setTimeout(1000)
//         // res.on(&quot;timeout&quot;,()=&gt;{console.log(&quot;响应超时&quot;)})
//         setTimeout(function() {
//             res.setHeader(&quot;Content-Type&quot;,&quot;text/html&quot;)
//             res.write(&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=&#39;utf-8&#39;/&gt;&lt;/head&gt;&quot;)
//             res.write(&quot;你好&quot;)
//             res.end()
//         }, 2000);
//     }
// }).listen(3000,&quot;127.0.0.1&quot;)
</code></pre>
<h2 id="index-js">index.js</h2>
<pre><code class="lang-js">webpackJsonp([&quot;joinOrg/index&quot;],{

/***/ &quot;/ocq&quot;:
/***/ (function(module, exports, __webpack_require__) {

&quot;use strict&quot;;
/* WEBPACK VAR INJECTION */(function(process) {

Object.defineProperty(exports, &quot;__esModule&quot;, {
  value: true
});

var _typeof = typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot; ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj; };

/**
  * vue-router v2.5.3
  * (c) 2017 Evan You
  * @license MIT
  */
/*  */

function assert(condition, message) {
  if (!condition) {
    throw new Error(&quot;[vue-router] &quot; + message);
  }
}

function warn(condition, message) {
  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !condition) {
    typeof console !== &#39;undefined&#39; &amp;&amp; console.warn(&quot;[vue-router] &quot; + message);
  }
}

var View = {
  name: &#39;router-view&#39;,
  functional: true,
  props: {
    name: {
      type: String,
      default: &#39;default&#39;
    }
  },
  render: function render(_, ref) {
    var props = ref.props;
    var children = ref.children;
    var parent = ref.parent;
    var data = ref.data;

    data.routerView = true;

    // directly use parent context&#39;s createElement() function
    // so that components rendered by router-view can resolve named slots
    var h = parent.$createElement;
    var name = props.name;
    var route = parent.$route;
    var cache = parent._routerViewCache || (parent._routerViewCache = {});

    // determine current view depth, also check to see if the tree
    // has been toggled inactive but kept-alive.
    var depth = 0;
    var inactive = false;
    while (parent) {
      if (parent.$vnode &amp;&amp; parent.$vnode.data.routerView) {
        depth++;
      }
      if (parent._inactive) {
        inactive = true;
      }
      parent = parent.$parent;
    }
    data.routerViewDepth = depth;

    // render previous view if the tree is inactive and kept-alive
    if (inactive) {
      return h(cache[name], data, children);
    }

    var matched = route.matched[depth];
    // render empty node if no matched route
    if (!matched) {
      cache[name] = null;
      return h();
    }

    var component = cache[name] = matched.components[name];

    // attach instance registration hook
    // this will be called in the instance&#39;s injected lifecycle hooks
    data.registerRouteInstance = function (vm, val) {
      // val could be undefined for unregistration
      var current = matched.instances[name];
      if (val &amp;&amp; current !== vm || !val &amp;&amp; current === vm) {
        matched.instances[name] = val;
      }
    }

    // also regiseter instance in prepatch hook
    // in case the same component instance is reused across different routes
    ;(data.hook || (data.hook = {})).prepatch = function (_, vnode) {
      matched.instances[name] = vnode.componentInstance;
    };

    // resolve props
    data.props = resolveProps(route, matched.props &amp;&amp; matched.props[name]);

    return h(component, data, children);
  }
};

function resolveProps(route, config) {
  switch (typeof config === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(config)) {
    case &#39;undefined&#39;:
      return;
    case &#39;object&#39;:
      return config;
    case &#39;function&#39;:
      return config(route);
    case &#39;boolean&#39;:
      return config ? route.params : undefined;
    default:
      if (process.env.NODE_ENV !== &#39;production&#39;) {
        warn(false, &quot;props in \&quot;&quot; + route.path + &quot;\&quot; is a &quot; + (typeof config === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(config)) + &quot;, &quot; + &quot;expecting an object, function or boolean.&quot;);
      }
  }
}

/*  */

var encodeReserveRE = /[!&#39;()*]/g;
var encodeReserveReplacer = function encodeReserveReplacer(c) {
  return &#39;%&#39; + c.charCodeAt(0).toString(16);
};
var commaRE = /%2C/g;

// fixed encodeURIComponent which is more conformant to RFC3986:
// - escapes [!&#39;()*]
// - preserve commas
var encode = function encode(str) {
  return encodeURIComponent(str).replace(encodeReserveRE, encodeReserveReplacer).replace(commaRE, &#39;,&#39;);
};

var decode = decodeURIComponent;

function resolveQuery(query, extraQuery, _parseQuery) {
  if (extraQuery === void 0) extraQuery = {};

  var parse = _parseQuery || parseQuery;
  var parsedQuery;
  try {
    parsedQuery = parse(query || &#39;&#39;);
  } catch (e) {
    process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(false, e.message);
    parsedQuery = {};
  }
  for (var key in extraQuery) {
    var val = extraQuery[key];
    parsedQuery[key] = Array.isArray(val) ? val.slice() : val;
  }
  return parsedQuery;
}

function parseQuery(query) {
  var res = {};

  query = query.trim().replace(/^(\?|#|&amp;)/, &#39;&#39;);

  if (!query) {
    return res;
  }

  query.split(&#39;&amp;&#39;).forEach(function (param) {
    var parts = param.replace(/\+/g, &#39; &#39;).split(&#39;=&#39;);
    var key = decode(parts.shift());
    var val = parts.length &gt; 0 ? decode(parts.join(&#39;=&#39;)) : null;

    if (res[key] === undefined) {
      res[key] = val;
    } else if (Array.isArray(res[key])) {
      res[key].push(val);
    } else {
      res[key] = [res[key], val];
    }
  });

  return res;
}

function stringifyQuery(obj) {
  var res = obj ? Object.keys(obj).map(function (key) {
    var val = obj[key];

    if (val === undefined) {
      return &#39;&#39;;
    }

    if (val === null) {
      return encode(key);
    }

    if (Array.isArray(val)) {
      var result = [];
      val.slice().forEach(function (val2) {
        if (val2 === undefined) {
          return;
        }
        if (val2 === null) {
          result.push(encode(key));
        } else {
          result.push(encode(key) + &#39;=&#39; + encode(val2));
        }
      });
      return result.join(&#39;&amp;&#39;);
    }

    return encode(key) + &#39;=&#39; + encode(val);
  }).filter(function (x) {
    return x.length &gt; 0;
  }).join(&#39;&amp;&#39;) : null;
  return res ? &quot;?&quot; + res : &#39;&#39;;
}

/*  */

var trailingSlashRE = /\/?$/;

function createRoute(record, location, redirectedFrom, router) {
  var stringifyQuery$$1 = router &amp;&amp; router.options.stringifyQuery;
  var route = {
    name: location.name || record &amp;&amp; record.name,
    meta: record &amp;&amp; record.meta || {},
    path: location.path || &#39;/&#39;,
    hash: location.hash || &#39;&#39;,
    query: location.query || {},
    params: location.params || {},
    fullPath: getFullPath(location, stringifyQuery$$1),
    matched: record ? formatMatch(record) : []
  };
  if (redirectedFrom) {
    route.redirectedFrom = getFullPath(redirectedFrom, stringifyQuery$$1);
  }
  return Object.freeze(route);
}

// the starting route that represents the initial state
var START = createRoute(null, {
  path: &#39;/&#39;
});

function formatMatch(record) {
  var res = [];
  while (record) {
    res.unshift(record);
    record = record.parent;
  }
  return res;
}

function getFullPath(ref, _stringifyQuery) {
  var path = ref.path;
  var query = ref.query;if (query === void 0) query = {};
  var hash = ref.hash;if (hash === void 0) hash = &#39;&#39;;

  var stringify = _stringifyQuery || stringifyQuery;
  return (path || &#39;/&#39;) + stringify(query) + hash;
}

function isSameRoute(a, b) {
  if (b === START) {
    return a === b;
  } else if (!b) {
    return false;
  } else if (a.path &amp;&amp; b.path) {
    return a.path.replace(trailingSlashRE, &#39;&#39;) === b.path.replace(trailingSlashRE, &#39;&#39;) &amp;&amp; a.hash === b.hash &amp;&amp; isObjectEqual(a.query, b.query);
  } else if (a.name &amp;&amp; b.name) {
    return a.name === b.name &amp;&amp; a.hash === b.hash &amp;&amp; isObjectEqual(a.query, b.query) &amp;&amp; isObjectEqual(a.params, b.params);
  } else {
    return false;
  }
}

function isObjectEqual(a, b) {
  if (a === void 0) a = {};
  if (b === void 0) b = {};

  var aKeys = Object.keys(a);
  var bKeys = Object.keys(b);
  if (aKeys.length !== bKeys.length) {
    return false;
  }
  return aKeys.every(function (key) {
    return String(a[key]) === String(b[key]);
  });
}

function isIncludedRoute(current, target) {
  return current.path.replace(trailingSlashRE, &#39;/&#39;).indexOf(target.path.replace(trailingSlashRE, &#39;/&#39;)) === 0 &amp;&amp; (!target.hash || current.hash === target.hash) &amp;&amp; queryIncludes(current.query, target.query);
}

function queryIncludes(current, target) {
  for (var key in target) {
    if (!(key in current)) {
      return false;
    }
  }
  return true;
}

/*  */

// work around weird flow bug
var toTypes = [String, Object];
var eventTypes = [String, Array];

var Link = {
  name: &#39;router-link&#39;,
  props: {
    to: {
      type: toTypes,
      required: true
    },
    tag: {
      type: String,
      default: &#39;a&#39;
    },
    exact: Boolean,
    append: Boolean,
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    event: {
      type: eventTypes,
      default: &#39;click&#39;
    }
  },
  render: function render(h) {
    var this$1 = this;

    var router = this.$router;
    var current = this.$route;
    var ref = router.resolve(this.to, current, this.append);
    var location = ref.location;
    var route = ref.route;
    var href = ref.href;

    var classes = {};
    var globalActiveClass = router.options.linkActiveClass;
    var globalExactActiveClass = router.options.linkExactActiveClass;
    // Support global empty active class
    var activeClassFallback = globalActiveClass == null ? &#39;router-link-active&#39; : globalActiveClass;
    var exactActiveClassFallback = globalExactActiveClass == null ? &#39;router-link-exact-active&#39; : globalExactActiveClass;
    var activeClass = this.activeClass == null ? activeClassFallback : this.activeClass;
    var exactActiveClass = this.exactActiveClass == null ? exactActiveClassFallback : this.exactActiveClass;
    var compareTarget = location.path ? createRoute(null, location, null, router) : route;

    classes[exactActiveClass] = isSameRoute(current, compareTarget);
    classes[activeClass] = this.exact ? classes[exactActiveClass] : isIncludedRoute(current, compareTarget);

    var handler = function handler(e) {
      if (guardEvent(e)) {
        if (this$1.replace) {
          router.replace(location);
        } else {
          router.push(location);
        }
      }
    };

    var on = { click: guardEvent };
    if (Array.isArray(this.event)) {
      this.event.forEach(function (e) {
        on[e] = handler;
      });
    } else {
      on[this.event] = handler;
    }

    var data = {
      class: classes
    };

    if (this.tag === &#39;a&#39;) {
      data.on = on;
      data.attrs = { href: href };
    } else {
      // find the first &lt;a&gt; child and apply listener and href
      var a = findAnchor(this.$slots.default);
      if (a) {
        // in case the &lt;a&gt; is a static node
        a.isStatic = false;
        var extend = _Vue.util.extend;
        var aData = a.data = extend({}, a.data);
        aData.on = on;
        var aAttrs = a.data.attrs = extend({}, a.data.attrs);
        aAttrs.href = href;
      } else {
        // doesn&#39;t have &lt;a&gt; child, apply listener to self
        data.on = on;
      }
    }

    return h(this.tag, data, this.$slots.default);
  }
};

function guardEvent(e) {
  // don&#39;t redirect with control keys
  if (e.metaKey || e.ctrlKey || e.shiftKey) {
    return;
  }
  // don&#39;t redirect when preventDefault called
  if (e.defaultPrevented) {
    return;
  }
  // don&#39;t redirect on right click
  if (e.button !== undefined &amp;&amp; e.button !== 0) {
    return;
  }
  // don&#39;t redirect if `target=&quot;_blank&quot;`
  if (e.currentTarget &amp;&amp; e.currentTarget.getAttribute) {
    var target = e.currentTarget.getAttribute(&#39;target&#39;);
    if (/\b_blank\b/i.test(target)) {
      return;
    }
  }
  // this may be a Weex event which doesn&#39;t have this method
  if (e.preventDefault) {
    e.preventDefault();
  }
  return true;
}

function findAnchor(children) {
  if (children) {
    var child;
    for (var i = 0; i &lt; children.length; i++) {
      child = children[i];
      if (child.tag === &#39;a&#39;) {
        return child;
      }
      if (child.children &amp;&amp; (child = findAnchor(child.children))) {
        return child;
      }
    }
  }
}

var _Vue;

function install(Vue) {
  if (install.installed) {
    return;
  }
  install.installed = true;

  _Vue = Vue;

  Object.defineProperty(Vue.prototype, &#39;$router&#39;, {
    get: function get() {
      return this.$root._router;
    }
  });

  Object.defineProperty(Vue.prototype, &#39;$route&#39;, {
    get: function get() {
      return this.$root._route;
    }
  });

  var isDef = function isDef(v) {
    return v !== undefined;
  };

  var registerInstance = function registerInstance(vm, callVal) {
    var i = vm.$options._parentVnode;
    if (isDef(i) &amp;&amp; isDef(i = i.data) &amp;&amp; isDef(i = i.registerRouteInstance)) {
      i(vm, callVal);
    }
  };

  Vue.mixin({
    beforeCreate: function beforeCreate() {
      if (isDef(this.$options.router)) {
        this._router = this.$options.router;
        this._router.init(this);
        Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current);
      }
      registerInstance(this, this);
    },
    destroyed: function destroyed() {
      registerInstance(this);
    }
  });

  Vue.component(&#39;router-view&#39;, View);
  Vue.component(&#39;router-link&#39;, Link);

  var strats = Vue.config.optionMergeStrategies;
  // use the same hook merging strategy for route hooks
  strats.beforeRouteEnter = strats.beforeRouteLeave = strats.created;
}

/*  */

var inBrowser = typeof window !== &#39;undefined&#39;;

/*  */

function resolvePath(relative, base, append) {
  var firstChar = relative.charAt(0);
  if (firstChar === &#39;/&#39;) {
    return relative;
  }

  if (firstChar === &#39;?&#39; || firstChar === &#39;#&#39;) {
    return base + relative;
  }

  var stack = base.split(&#39;/&#39;);

  // remove trailing segment if:
  // - not appending
  // - appending to trailing slash (last segment is empty)
  if (!append || !stack[stack.length - 1]) {
    stack.pop();
  }

  // resolve relative path
  var segments = relative.replace(/^\//, &#39;&#39;).split(&#39;/&#39;);
  for (var i = 0; i &lt; segments.length; i++) {
    var segment = segments[i];
    if (segment === &#39;..&#39;) {
      stack.pop();
    } else if (segment !== &#39;.&#39;) {
      stack.push(segment);
    }
  }

  // ensure leading slash
  if (stack[0] !== &#39;&#39;) {
    stack.unshift(&#39;&#39;);
  }

  return stack.join(&#39;/&#39;);
}

function parsePath(path) {
  var hash = &#39;&#39;;
  var query = &#39;&#39;;

  var hashIndex = path.indexOf(&#39;#&#39;);
  if (hashIndex &gt;= 0) {
    hash = path.slice(hashIndex);
    path = path.slice(0, hashIndex);
  }

  var queryIndex = path.indexOf(&#39;?&#39;);
  if (queryIndex &gt;= 0) {
    query = path.slice(queryIndex + 1);
    path = path.slice(0, queryIndex);
  }

  return {
    path: path,
    query: query,
    hash: hash
  };
}

function cleanPath(path) {
  return path.replace(/\/\//g, &#39;/&#39;);
}

var index$1 = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == &#39;[object Array]&#39;;
};

/**
 * Expose `pathToRegexp`.
 */
var index = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
// Match escaped characters that would otherwise appear in future matches.
// This allows the user to escape special characters that won&#39;t transform.
&#39;(\\\\.)&#39;,
// Match Express-style parameters and un-named parameters with a prefix
// and optional suffixes. Matches appear as:
//
// &quot;/:test(\\d+)?&quot; =&gt; [&quot;/&quot;, &quot;test&quot;, &quot;\d+&quot;, undefined, &quot;?&quot;, undefined]
// &quot;/route(\\d+)&quot;  =&gt; [undefined, undefined, undefined, &quot;\d+&quot;, undefined, undefined]
// &quot;/*&quot;            =&gt; [&quot;/&quot;, undefined, undefined, undefined, undefined, &quot;*&quot;]
&#39;([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))&#39;].join(&#39;|&#39;), &#39;g&#39;);

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse(str, options) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = &#39;&#39;;
  var defaultDelimiter = options &amp;&amp; options.delimiter || &#39;/&#39;;
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue;
    }

    var next = str[index];
    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var modifier = res[6];
    var asterisk = res[7];

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = &#39;&#39;;
    }

    var partial = prefix != null &amp;&amp; next != null &amp;&amp; next !== prefix;
    var repeat = modifier === &#39;+&#39; || modifier === &#39;*&#39;;
    var optional = modifier === &#39;?&#39; || modifier === &#39;*&#39;;
    var delimiter = res[2] || defaultDelimiter;
    var pattern = capture || group;

    tokens.push({
      name: name || key++,
      prefix: prefix || &#39;&#39;,
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : asterisk ? &#39;.*&#39; : &#39;[^&#39; + escapeString(delimiter) + &#39;]+?&#39;
    });
  }

  // Match any characters still remaining.
  if (index &lt; str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens;
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile(str, options) {
  return tokensToFunction(parse(str, options));
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty(str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return &#39;%&#39; + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk(str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return &#39;%&#39; + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction(tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i &lt; tokens.length; i++) {
    if (_typeof(tokens[i]) === &#39;object&#39;) {
      matches[i] = new RegExp(&#39;^(?:&#39; + tokens[i].pattern + &#39;)$&#39;);
    }
  }

  return function (obj, opts) {
    var path = &#39;&#39;;
    var data = obj || {};
    var options = opts || {};
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent;

    for (var i = 0; i &lt; tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === &#39;string&#39;) {
        path += token;

        continue;
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix;
          }

          continue;
        } else {
          throw new TypeError(&#39;Expected &quot;&#39; + token.name + &#39;&quot; to be defined&#39;);
        }
      }

      if (index$1(value)) {
        if (!token.repeat) {
          throw new TypeError(&#39;Expected &quot;&#39; + token.name + &#39;&quot; to not repeat, but received `&#39; + JSON.stringify(value) + &#39;`&#39;);
        }

        if (value.length === 0) {
          if (token.optional) {
            continue;
          } else {
            throw new TypeError(&#39;Expected &quot;&#39; + token.name + &#39;&quot; to not be empty&#39;);
          }
        }

        for (var j = 0; j &lt; value.length; j++) {
          segment = encode(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError(&#39;Expected all &quot;&#39; + token.name + &#39;&quot; to match &quot;&#39; + token.pattern + &#39;&quot;, but received `&#39; + JSON.stringify(segment) + &#39;`&#39;);
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue;
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value);

      if (!matches[i].test(segment)) {
        throw new TypeError(&#39;Expected &quot;&#39; + token.name + &#39;&quot; to match &quot;&#39; + token.pattern + &#39;&quot;, but received &quot;&#39; + segment + &#39;&quot;&#39;);
      }

      path += token.prefix + segment;
    }

    return path;
  };
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, &#39;\\$1&#39;);
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup(group) {
  return group.replace(/([=!:$\/()])/g, &#39;\\$1&#39;);
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys(re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags(options) {
  return options.sensitive ? &#39;&#39; : &#39;i&#39;;
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp(path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i &lt; groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp(path, keys, options) {
  var parts = [];

  for (var i = 0; i &lt; path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp(&#39;(?:&#39; + parts.join(&#39;|&#39;) + &#39;)&#39;, flags(options));

  return attachKeys(regexp, keys);
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp(path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options);
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp(tokens, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = &#39;&#39;;

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i &lt; tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === &#39;string&#39;) {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = &#39;(?:&#39; + token.pattern + &#39;)&#39;;

      keys.push(token);

      if (token.repeat) {
        capture += &#39;(?:&#39; + prefix + capture + &#39;)*&#39;;
      }

      if (token.optional) {
        if (!token.partial) {
          capture = &#39;(?:&#39; + prefix + &#39;(&#39; + capture + &#39;))?&#39;;
        } else {
          capture = prefix + &#39;(&#39; + capture + &#39;)?&#39;;
        }
      } else {
        capture = prefix + &#39;(&#39; + capture + &#39;)&#39;;
      }

      route += capture;
    }
  }

  var delimiter = escapeString(options.delimiter || &#39;/&#39;);
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter;

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where &quot;/test/&quot; shouldn&#39;t match &quot;/test//route&quot;.
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + &#39;(?:&#39; + delimiter + &#39;(?=$))?&#39;;
  }

  if (end) {
    route += &#39;$&#39;;
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict &amp;&amp; endsWithDelimiter ? &#39;&#39; : &#39;(?=&#39; + delimiter + &#39;|$)&#39;;
  }

  return attachKeys(new RegExp(&#39;^&#39; + route, flags(options)), keys);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: &#39;id&#39;, delimiter: &#39;/&#39;, optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp(path, keys, options) {
  if (!index$1(keys)) {
    options = /** @type {!Object} */keys || options;
    keys = [];
  }

  options = options || {};

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */keys);
  }

  if (index$1(path)) {
    return arrayToRegexp( /** @type {!Array} */path, /** @type {!Array} */keys, options);
  }

  return stringToRegexp( /** @type {string} */path, /** @type {!Array} */keys, options);
}

index.parse = parse_1;
index.compile = compile_1;
index.tokensToFunction = tokensToFunction_1;
index.tokensToRegExp = tokensToRegExp_1;

/*  */

var regexpCompileCache = Object.create(null);

function fillParams(path, params, routeMsg) {
  try {
    var filler = regexpCompileCache[path] || (regexpCompileCache[path] = index.compile(path));
    return filler(params || {}, { pretty: true });
  } catch (e) {
    if (process.env.NODE_ENV !== &#39;production&#39;) {
      warn(false, &quot;missing param for &quot; + routeMsg + &quot;: &quot; + e.message);
    }
    return &#39;&#39;;
  }
}

/*  */

function createRouteMap(routes, oldPathList, oldPathMap, oldNameMap) {
  // the path list is used to control path matching priority
  var pathList = oldPathList || [];
  var pathMap = oldPathMap || Object.create(null);
  var nameMap = oldNameMap || Object.create(null);

  routes.forEach(function (route) {
    addRouteRecord(pathList, pathMap, nameMap, route);
  });

  // ensure wildcard routes are always at the end
  for (var i = 0, l = pathList.length; i &lt; l; i++) {
    if (pathList[i] === &#39;*&#39;) {
      pathList.push(pathList.splice(i, 1)[0]);
      l--;
      i--;
    }
  }

  return {
    pathList: pathList,
    pathMap: pathMap,
    nameMap: nameMap
  };
}

function addRouteRecord(pathList, pathMap, nameMap, route, parent, matchAs) {
  var path = route.path;
  var name = route.name;
  if (process.env.NODE_ENV !== &#39;production&#39;) {
    assert(path != null, &quot;\&quot;path\&quot; is required in a route configuration.&quot;);
    assert(typeof route.component !== &#39;string&#39;, &quot;route config \&quot;component\&quot; for path: &quot; + String(path || name) + &quot; cannot be a &quot; + &quot;string id. Use an actual component instead.&quot;);
  }

  var normalizedPath = normalizePath(path, parent);
  var record = {
    path: normalizedPath,
    regex: compileRouteRegex(normalizedPath),
    components: route.components || { default: route.component },
    instances: {},
    name: name,
    parent: parent,
    matchAs: matchAs,
    redirect: route.redirect,
    beforeEnter: route.beforeEnter,
    meta: route.meta || {},
    props: route.props == null ? {} : route.components ? route.props : { default: route.props }
  };

  if (route.children) {
    // Warn if route is named and has a default child route.
    // If users navigate to this route by name, the default child will
    // not be rendered (GH Issue #629)
    if (process.env.NODE_ENV !== &#39;production&#39;) {
      if (route.name &amp;&amp; route.children.some(function (child) {
        return (/^\/?$/.test(child.path)
        );
      })) {
        warn(false, &quot;Named Route &#39;&quot; + route.name + &quot;&#39; has a default child route. &quot; + &quot;When navigating to this named route (:to=\&quot;{name: &#39;&quot; + route.name + &quot;&#39;\&quot;), &quot; + &quot;the default child route will not be rendered. Remove the name from &quot; + &quot;this route and use the name of the default child route for named &quot; + &quot;links instead.&quot;);
      }
    }
    route.children.forEach(function (child) {
      var childMatchAs = matchAs ? cleanPath(matchAs + &quot;/&quot; + child.path) : undefined;
      addRouteRecord(pathList, pathMap, nameMap, child, record, childMatchAs);
    });
  }

  if (route.alias !== undefined) {
    if (Array.isArray(route.alias)) {
      route.alias.forEach(function (alias) {
        var aliasRoute = {
          path: alias,
          children: route.children
        };
        addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path);
      });
    } else {
      var aliasRoute = {
        path: route.alias,
        children: route.children
      };
      addRouteRecord(pathList, pathMap, nameMap, aliasRoute, parent, record.path);
    }
  }

  if (!pathMap[record.path]) {
    pathList.push(record.path);
    pathMap[record.path] = record;
  }

  if (name) {
    if (!nameMap[name]) {
      nameMap[name] = record;
    } else if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !matchAs) {
      warn(false, &quot;Duplicate named routes definition: &quot; + &quot;{ name: \&quot;&quot; + name + &quot;\&quot;, path: \&quot;&quot; + record.path + &quot;\&quot; }&quot;);
    }
  }
}

function compileRouteRegex(path) {
  var regex = index(path);
  if (process.env.NODE_ENV !== &#39;production&#39;) {
    var keys = {};
    regex.keys.forEach(function (key) {
      warn(!keys[key.name], &quot;Duplicate param keys in route with path: \&quot;&quot; + path + &quot;\&quot;&quot;);
      keys[key.name] = true;
    });
  }
  return regex;
}

function normalizePath(path, parent) {
  path = path.replace(/\/$/, &#39;&#39;);
  if (path[0] === &#39;/&#39;) {
    return path;
  }
  if (parent == null) {
    return path;
  }
  return cleanPath(parent.path + &quot;/&quot; + path);
}

/*  */

function normalizeLocation(raw, current, append, router) {
  var next = typeof raw === &#39;string&#39; ? { path: raw } : raw;
  // named target
  if (next.name || next._normalized) {
    return next;
  }

  // relative params
  if (!next.path &amp;&amp; next.params &amp;&amp; current) {
    next = assign({}, next);
    next._normalized = true;
    var params = assign(assign({}, current.params), next.params);
    if (current.name) {
      next.name = current.name;
      next.params = params;
    } else if (current.matched) {
      var rawPath = current.matched[current.matched.length - 1].path;
      next.path = fillParams(rawPath, params, &quot;path &quot; + current.path);
    } else if (process.env.NODE_ENV !== &#39;production&#39;) {
      warn(false, &quot;relative params navigation requires a current route.&quot;);
    }
    return next;
  }

  var parsedPath = parsePath(next.path || &#39;&#39;);
  var basePath = current &amp;&amp; current.path || &#39;/&#39;;
  var path = parsedPath.path ? resolvePath(parsedPath.path, basePath, append || next.append) : basePath;

  var query = resolveQuery(parsedPath.query, next.query, router &amp;&amp; router.options.parseQuery);

  var hash = next.hash || parsedPath.hash;
  if (hash &amp;&amp; hash.charAt(0) !== &#39;#&#39;) {
    hash = &quot;#&quot; + hash;
  }

  return {
    _normalized: true,
    path: path,
    query: query,
    hash: hash
  };
}

function assign(a, b) {
  for (var key in b) {
    a[key] = b[key];
  }
  return a;
}

/*  */

function createMatcher(routes, router) {
  var ref = createRouteMap(routes);
  var pathList = ref.pathList;
  var pathMap = ref.pathMap;
  var nameMap = ref.nameMap;

  function addRoutes(routes) {
    createRouteMap(routes, pathList, pathMap, nameMap);
  }

  function match(raw, currentRoute, redirectedFrom) {
    var location = normalizeLocation(raw, currentRoute, false, router);
    var name = location.name;

    if (name) {
      var record = nameMap[name];
      if (process.env.NODE_ENV !== &#39;production&#39;) {
        warn(record, &quot;Route with name &#39;&quot; + name + &quot;&#39; does not exist&quot;);
      }
      var paramNames = record.regex.keys.filter(function (key) {
        return !key.optional;
      }).map(function (key) {
        return key.name;
      });

      if (_typeof(location.params) !== &#39;object&#39;) {
        location.params = {};
      }

      if (currentRoute &amp;&amp; _typeof(currentRoute.params) === &#39;object&#39;) {
        for (var key in currentRoute.params) {
          if (!(key in location.params) &amp;&amp; paramNames.indexOf(key) &gt; -1) {
            location.params[key] = currentRoute.params[key];
          }
        }
      }

      if (record) {
        location.path = fillParams(record.path, location.params, &quot;named route \&quot;&quot; + name + &quot;\&quot;&quot;);
        return _createRoute(record, location, redirectedFrom);
      }
    } else if (location.path) {
      location.params = {};
      for (var i = 0; i &lt; pathList.length; i++) {
        var path = pathList[i];
        var record$1 = pathMap[path];
        if (matchRoute(record$1.regex, location.path, location.params)) {
          return _createRoute(record$1, location, redirectedFrom);
        }
      }
    }
    // no match
    return _createRoute(null, location);
  }

  function redirect(record, location) {
    var originalRedirect = record.redirect;
    var redirect = typeof originalRedirect === &#39;function&#39; ? originalRedirect(createRoute(record, location, null, router)) : originalRedirect;

    if (typeof redirect === &#39;string&#39;) {
      redirect = { path: redirect };
    }

    if (!redirect || (typeof redirect === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(redirect)) !== &#39;object&#39;) {
      if (process.env.NODE_ENV !== &#39;production&#39;) {
        warn(false, &quot;invalid redirect option: &quot; + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }

    var re = redirect;
    var name = re.name;
    var path = re.path;
    var query = location.query;
    var hash = location.hash;
    var params = location.params;
    query = re.hasOwnProperty(&#39;query&#39;) ? re.query : query;
    hash = re.hasOwnProperty(&#39;hash&#39;) ? re.hash : hash;
    params = re.hasOwnProperty(&#39;params&#39;) ? re.params : params;

    if (name) {
      // resolved named direct
      var targetRecord = nameMap[name];
      if (process.env.NODE_ENV !== &#39;production&#39;) {
        assert(targetRecord, &quot;redirect failed: named route \&quot;&quot; + name + &quot;\&quot; not found.&quot;);
      }
      return match({
        _normalized: true,
        name: name,
        query: query,
        hash: hash,
        params: params
      }, undefined, location);
    } else if (path) {
      // 1. resolve relative redirect
      var rawPath = resolveRecordPath(path, record);
      // 2. resolve params
      var resolvedPath = fillParams(rawPath, params, &quot;redirect route with path \&quot;&quot; + rawPath + &quot;\&quot;&quot;);
      // 3. rematch with existing query and hash
      return match({
        _normalized: true,
        path: resolvedPath,
        query: query,
        hash: hash
      }, undefined, location);
    } else {
      if (process.env.NODE_ENV !== &#39;production&#39;) {
        warn(false, &quot;invalid redirect option: &quot; + JSON.stringify(redirect));
      }
      return _createRoute(null, location);
    }
  }

  function alias(record, location, matchAs) {
    var aliasedPath = fillParams(matchAs, location.params, &quot;aliased route with path \&quot;&quot; + matchAs + &quot;\&quot;&quot;);
    var aliasedMatch = match({
      _normalized: true,
      path: aliasedPath
    });
    if (aliasedMatch) {
      var matched = aliasedMatch.matched;
      var aliasedRecord = matched[matched.length - 1];
      location.params = aliasedMatch.params;
      return _createRoute(aliasedRecord, location);
    }
    return _createRoute(null, location);
  }

  function _createRoute(record, location, redirectedFrom) {
    if (record &amp;&amp; record.redirect) {
      return redirect(record, redirectedFrom || location);
    }
    if (record &amp;&amp; record.matchAs) {
      return alias(record, location, record.matchAs);
    }
    return createRoute(record, location, redirectedFrom, router);
  }

  return {
    match: match,
    addRoutes: addRoutes
  };
}

function matchRoute(regex, path, params) {
  var m = path.match(regex);

  if (!m) {
    return false;
  } else if (!params) {
    return true;
  }

  for (var i = 1, len = m.length; i &lt; len; ++i) {
    var key = regex.keys[i - 1];
    var val = typeof m[i] === &#39;string&#39; ? decodeURIComponent(m[i]) : m[i];
    if (key) {
      params[key.name] = val;
    }
  }

  return true;
}

function resolveRecordPath(path, record) {
  return resolvePath(path, record.parent ? record.parent.path : &#39;/&#39;, true);
}

/*  */

var positionStore = Object.create(null);

function setupScroll() {
  window.addEventListener(&#39;popstate&#39;, function (e) {
    saveScrollPosition();
    if (e.state &amp;&amp; e.state.key) {
      setStateKey(e.state.key);
    }
  });
}

function handleScroll(router, to, from, isPop) {
  if (!router.app) {
    return;
  }

  var behavior = router.options.scrollBehavior;
  if (!behavior) {
    return;
  }

  if (process.env.NODE_ENV !== &#39;production&#39;) {
    assert(typeof behavior === &#39;function&#39;, &quot;scrollBehavior must be a function&quot;);
  }

  // wait until re-render finishes before scrolling
  router.app.$nextTick(function () {
    var position = getScrollPosition();
    var shouldScroll = behavior(to, from, isPop ? position : null);
    if (!shouldScroll) {
      return;
    }
    var isObject = (typeof shouldScroll === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(shouldScroll)) === &#39;object&#39;;
    if (isObject &amp;&amp; typeof shouldScroll.selector === &#39;string&#39;) {
      var el = document.querySelector(shouldScroll.selector);
      if (el) {
        position = getElementPosition(el);
      } else if (isValidPosition(shouldScroll)) {
        position = normalizePosition(shouldScroll);
      }
    } else if (isObject &amp;&amp; isValidPosition(shouldScroll)) {
      position = normalizePosition(shouldScroll);
    }

    if (position) {
      window.scrollTo(position.x, position.y);
    }
  });
}

function saveScrollPosition() {
  var key = getStateKey();
  if (key) {
    positionStore[key] = {
      x: window.pageXOffset,
      y: window.pageYOffset
    };
  }
}

function getScrollPosition() {
  var key = getStateKey();
  if (key) {
    return positionStore[key];
  }
}

function getElementPosition(el) {
  var docEl = document.documentElement;
  var docRect = docEl.getBoundingClientRect();
  var elRect = el.getBoundingClientRect();
  return {
    x: elRect.left - docRect.left,
    y: elRect.top - docRect.top
  };
}

function isValidPosition(obj) {
  return isNumber(obj.x) || isNumber(obj.y);
}

function normalizePosition(obj) {
  return {
    x: isNumber(obj.x) ? obj.x : window.pageXOffset,
    y: isNumber(obj.y) ? obj.y : window.pageYOffset
  };
}

function isNumber(v) {
  return typeof v === &#39;number&#39;;
}

/*  */

var supportsPushState = inBrowser &amp;&amp; function () {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf(&#39;Android 2.&#39;) !== -1 || ua.indexOf(&#39;Android 4.0&#39;) !== -1) &amp;&amp; ua.indexOf(&#39;Mobile Safari&#39;) !== -1 &amp;&amp; ua.indexOf(&#39;Chrome&#39;) === -1 &amp;&amp; ua.indexOf(&#39;Windows Phone&#39;) === -1) {
    return false;
  }

  return window.history &amp;&amp; &#39;pushState&#39; in window.history;
}();

// use User Timing api (if present) for more accurate key precision
var Time = inBrowser &amp;&amp; window.performance &amp;&amp; window.performance.now ? window.performance : Date;

var _key = genKey();

function genKey() {
  return Time.now().toFixed(3);
}

function getStateKey() {
  return _key;
}

function setStateKey(key) {
  _key = key;
}

function pushState(url, replace) {
  saveScrollPosition();
  // try...catch the pushState call to get around Safari
  // DOM Exception 18 where it limits to 100 pushState calls
  var history = window.history;
  try {
    if (replace) {
      history.replaceState({ key: _key }, &#39;&#39;, url);
    } else {
      _key = genKey();
      history.pushState({ key: _key }, &#39;&#39;, url);
    }
  } catch (e) {
    window.location[replace ? &#39;replace&#39; : &#39;assign&#39;](url);
  }
}

function replaceState(url) {
  pushState(url, true);
}

/*  */

function runQueue(queue, fn, cb) {
  var step = function step(index) {
    if (index &gt;= queue.length) {
      cb();
    } else {
      if (queue[index]) {
        fn(queue[index], function () {
          step(index + 1);
        });
      } else {
        step(index + 1);
      }
    }
  };
  step(0);
}

/*  */

var History = function History(router, base) {
  this.router = router;
  this.base = normalizeBase(base);
  // start with a route object that stands for &quot;nowhere&quot;
  this.current = START;
  this.pending = null;
  this.ready = false;
  this.readyCbs = [];
  this.readyErrorCbs = [];
  this.errorCbs = [];
};

History.prototype.listen = function listen(cb) {
  this.cb = cb;
};

History.prototype.onReady = function onReady(cb, errorCb) {
  if (this.ready) {
    cb();
  } else {
    this.readyCbs.push(cb);
    if (errorCb) {
      this.readyErrorCbs.push(errorCb);
    }
  }
};

History.prototype.onError = function onError(errorCb) {
  this.errorCbs.push(errorCb);
};

History.prototype.transitionTo = function transitionTo(location, onComplete, onAbort) {
  var this$1 = this;

  var route = this.router.match(location, this.current);
  this.confirmTransition(route, function () {
    this$1.updateRoute(route);
    onComplete &amp;&amp; onComplete(route);
    this$1.ensureURL();

    // fire ready cbs once
    if (!this$1.ready) {
      this$1.ready = true;
      this$1.readyCbs.forEach(function (cb) {
        cb(route);
      });
    }
  }, function (err) {
    if (onAbort) {
      onAbort(err);
    }
    if (err &amp;&amp; !this$1.ready) {
      this$1.ready = true;
      this$1.readyErrorCbs.forEach(function (cb) {
        cb(err);
      });
    }
  });
};

History.prototype.confirmTransition = function confirmTransition(route, onComplete, onAbort) {
  var this$1 = this;

  var current = this.current;
  var abort = function abort(err) {
    if (isError(err)) {
      if (this$1.errorCbs.length) {
        this$1.errorCbs.forEach(function (cb) {
          cb(err);
        });
      } else {
        warn(false, &#39;uncaught error during route navigation:&#39;);
        console.error(err);
      }
    }
    onAbort &amp;&amp; onAbort(err);
  };
  if (isSameRoute(route, current) &amp;&amp;
  // in the case the route map has been dynamically appended to
  route.matched.length === current.matched.length) {
    this.ensureURL();
    return abort();
  }

  var ref = resolveQueue(this.current.matched, route.matched);
  var updated = ref.updated;
  var deactivated = ref.deactivated;
  var activated = ref.activated;

  var queue = [].concat(
  // in-component leave guards
  extractLeaveGuards(deactivated),
  // global before hooks
  this.router.beforeHooks,
  // in-component update hooks
  extractUpdateHooks(updated),
  // in-config enter guards
  activated.map(function (m) {
    return m.beforeEnter;
  }),
  // async components
  resolveAsyncComponents(activated));

  this.pending = route;
  var iterator = function iterator(hook, next) {
    if (this$1.pending !== route) {
      return abort();
    }
    try {
      hook(route, current, function (to) {
        if (to === false || isError(to)) {
          // next(false) -&gt; abort navigation, ensure current URL
          this$1.ensureURL(true);
          abort(to);
        } else if (typeof to === &#39;string&#39; || (typeof to === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(to)) === &#39;object&#39; &amp;&amp; (typeof to.path === &#39;string&#39; || typeof to.name === &#39;string&#39;)) {
          // next(&#39;/&#39;) or next({ path: &#39;/&#39; }) -&gt; redirect
          abort();
          if ((typeof to === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(to)) === &#39;object&#39; &amp;&amp; to.replace) {
            this$1.replace(to);
          } else {
            this$1.push(to);
          }
        } else {
          // confirm transition and pass on the value
          next(to);
        }
      });
    } catch (e) {
      abort(e);
    }
  };

  runQueue(queue, iterator, function () {
    var postEnterCbs = [];
    var isValid = function isValid() {
      return this$1.current === route;
    };
    // wait until async components are resolved before
    // extracting in-component enter guards
    var enterGuards = extractEnterGuards(activated, postEnterCbs, isValid);
    var queue = enterGuards.concat(this$1.router.resolveHooks);
    runQueue(queue, iterator, function () {
      if (this$1.pending !== route) {
        return abort();
      }
      this$1.pending = null;
      onComplete(route);
      if (this$1.router.app) {
        this$1.router.app.$nextTick(function () {
          postEnterCbs.forEach(function (cb) {
            cb();
          });
        });
      }
    });
  });
};

History.prototype.updateRoute = function updateRoute(route) {
  var prev = this.current;
  this.current = route;
  this.cb &amp;&amp; this.cb(route);
  this.router.afterHooks.forEach(function (hook) {
    hook &amp;&amp; hook(route, prev);
  });
};

function normalizeBase(base) {
  if (!base) {
    if (inBrowser) {
      // respect &lt;base&gt; tag
      var baseEl = document.querySelector(&#39;base&#39;);
      base = baseEl &amp;&amp; baseEl.getAttribute(&#39;href&#39;) || &#39;/&#39;;
    } else {
      base = &#39;/&#39;;
    }
  }
  // make sure there&#39;s the starting slash
  if (base.charAt(0) !== &#39;/&#39;) {
    base = &#39;/&#39; + base;
  }
  // remove trailing slash
  return base.replace(/\/$/, &#39;&#39;);
}

function resolveQueue(current, next) {
  var i;
  var max = Math.max(current.length, next.length);
  for (i = 0; i &lt; max; i++) {
    if (current[i] !== next[i]) {
      break;
    }
  }
  return {
    updated: next.slice(0, i),
    activated: next.slice(i),
    deactivated: current.slice(i)
  };
}

function extractGuards(records, name, bind, reverse) {
  var guards = flatMapComponents(records, function (def, instance, match, key) {
    var guard = extractGuard(def, name);
    if (guard) {
      return Array.isArray(guard) ? guard.map(function (guard) {
        return bind(guard, instance, match, key);
      }) : bind(guard, instance, match, key);
    }
  });
  return flatten(reverse ? guards.reverse() : guards);
}

function extractGuard(def, key) {
  if (typeof def !== &#39;function&#39;) {
    // extend now so that global mixins are applied.
    def = _Vue.extend(def);
  }
  return def.options[key];
}

function extractLeaveGuards(deactivated) {
  return extractGuards(deactivated, &#39;beforeRouteLeave&#39;, bindGuard, true);
}

function extractUpdateHooks(updated) {
  return extractGuards(updated, &#39;beforeRouteUpdate&#39;, bindGuard);
}

function bindGuard(guard, instance) {
  if (instance) {
    return function boundRouteGuard() {
      return guard.apply(instance, arguments);
    };
  }
}

function extractEnterGuards(activated, cbs, isValid) {
  return extractGuards(activated, &#39;beforeRouteEnter&#39;, function (guard, _, match, key) {
    return bindEnterGuard(guard, match, key, cbs, isValid);
  });
}

function bindEnterGuard(guard, match, key, cbs, isValid) {
  return function routeEnterGuard(to, from, next) {
    return guard(to, from, function (cb) {
      next(cb);
      if (typeof cb === &#39;function&#39;) {
        cbs.push(function () {
          // #750
          // if a router-view is wrapped with an out-in transition,
          // the instance may not have been registered at this time.
          // we will need to poll for registration until current route
          // is no longer valid.
          poll(cb, match.instances, key, isValid);
        });
      }
    });
  };
}

function poll(cb, // somehow flow cannot infer this is a function
instances, key, isValid) {
  if (instances[key]) {
    cb(instances[key]);
  } else if (isValid()) {
    setTimeout(function () {
      poll(cb, instances, key, isValid);
    }, 16);
  }
}

function resolveAsyncComponents(matched) {
  return function (to, from, next) {
    var hasAsync = false;
    var pending = 0;
    var error = null;

    flatMapComponents(matched, function (def, _, match, key) {
      // if it&#39;s a function and doesn&#39;t have cid attached,
      // assume it&#39;s an async component resolve function.
      // we are not using Vue&#39;s default async resolving mechanism because
      // we want to halt the navigation until the incoming component has been
      // resolved.
      if (typeof def === &#39;function&#39; &amp;&amp; def.cid === undefined) {
        hasAsync = true;
        pending++;

        var resolve = once(function (resolvedDef) {
          // save resolved on async factory in case it&#39;s used elsewhere
          def.resolved = typeof resolvedDef === &#39;function&#39; ? resolvedDef : _Vue.extend(resolvedDef);
          match.components[key] = resolvedDef;
          pending--;
          if (pending &lt;= 0) {
            next();
          }
        });

        var reject = once(function (reason) {
          var msg = &quot;Failed to resolve async component &quot; + key + &quot;: &quot; + reason;
          process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn(false, msg);
          if (!error) {
            error = isError(reason) ? reason : new Error(msg);
            next(error);
          }
        });

        var res;
        try {
          res = def(resolve, reject);
        } catch (e) {
          reject(e);
        }
        if (res) {
          if (typeof res.then === &#39;function&#39;) {
            res.then(resolve, reject);
          } else {
            // new syntax in Vue 2.3
            var comp = res.component;
            if (comp &amp;&amp; typeof comp.then === &#39;function&#39;) {
              comp.then(resolve, reject);
            }
          }
        }
      }
    });

    if (!hasAsync) {
      next();
    }
  };
}

function flatMapComponents(matched, fn) {
  return flatten(matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return fn(m.components[key], m.instances[key], m, key);
    });
  }));
}

function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}

// in Webpack 2, require.ensure now also returns a Promise
// so the resolve/reject functions may get called an extra time
// if the user uses an arrow function shorthand that happens to
// return that Promise.
function once(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    return fn.apply(this, arguments);
  };
}

function isError(err) {
  return Object.prototype.toString.call(err).indexOf(&#39;Error&#39;) &gt; -1;
}

/*  */

var HTML5History = function (History$$1) {
  function HTML5History(router, base) {
    var this$1 = this;

    History$$1.call(this, router, base);

    var expectScroll = router.options.scrollBehavior;

    if (expectScroll) {
      setupScroll();
    }

    window.addEventListener(&#39;popstate&#39;, function (e) {
      this$1.transitionTo(getLocation(this$1.base), function (route) {
        if (expectScroll) {
          handleScroll(router, route, this$1.current, true);
        }
      });
    });
  }

  if (History$$1) HTML5History.__proto__ = History$$1;
  HTML5History.prototype = Object.create(History$$1 &amp;&amp; History$$1.prototype);
  HTML5History.prototype.constructor = HTML5History;

  HTML5History.prototype.go = function go(n) {
    window.history.go(n);
  };

  HTML5History.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      pushState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete &amp;&amp; onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    var ref = this;
    var fromRoute = ref.current;
    this.transitionTo(location, function (route) {
      replaceState(cleanPath(this$1.base + route.fullPath));
      handleScroll(this$1.router, route, fromRoute, false);
      onComplete &amp;&amp; onComplete(route);
    }, onAbort);
  };

  HTML5History.prototype.ensureURL = function ensureURL(push) {
    if (getLocation(this.base) !== this.current.fullPath) {
      var current = cleanPath(this.base + this.current.fullPath);
      push ? pushState(current) : replaceState(current);
    }
  };

  HTML5History.prototype.getCurrentLocation = function getCurrentLocation() {
    return getLocation(this.base);
  };

  return HTML5History;
}(History);

function getLocation(base) {
  var path = window.location.pathname;
  if (base &amp;&amp; path.indexOf(base) === 0) {
    path = path.slice(base.length);
  }
  return (path || &#39;/&#39;) + window.location.search + window.location.hash;
}

/*  */

var HashHistory = function (History$$1) {
  function HashHistory(router, base, fallback) {
    History$$1.call(this, router, base);
    // check history fallback deeplinking
    if (fallback &amp;&amp; checkFallback(this.base)) {
      return;
    }
    ensureSlash();
  }

  if (History$$1) HashHistory.__proto__ = History$$1;
  HashHistory.prototype = Object.create(History$$1 &amp;&amp; History$$1.prototype);
  HashHistory.prototype.constructor = HashHistory;

  // this is delayed until the app mounts
  // to avoid the hashchange listener being fired too early
  HashHistory.prototype.setupListeners = function setupListeners() {
    var this$1 = this;

    window.addEventListener(&#39;hashchange&#39;, function () {
      if (!ensureSlash()) {
        return;
      }
      this$1.transitionTo(getHash(), function (route) {
        replaceHash(route.fullPath);
      });
    });
  };

  HashHistory.prototype.push = function push(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      pushHash(route.fullPath);
      onComplete &amp;&amp; onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    this.transitionTo(location, function (route) {
      replaceHash(route.fullPath);
      onComplete &amp;&amp; onComplete(route);
    }, onAbort);
  };

  HashHistory.prototype.go = function go(n) {
    window.history.go(n);
  };

  HashHistory.prototype.ensureURL = function ensureURL(push) {
    var current = this.current.fullPath;
    if (getHash() !== current) {
      push ? pushHash(current) : replaceHash(current);
    }
  };

  HashHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    return getHash();
  };

  return HashHistory;
}(History);

function checkFallback(base) {
  var location = getLocation(base);
  if (!/^\/#/.test(location)) {
    window.location.replace(cleanPath(base + &#39;/#&#39; + location));
    return true;
  }
}

function ensureSlash() {
  var path = getHash();
  if (path.charAt(0) === &#39;/&#39;) {
    return true;
  }
  replaceHash(&#39;/&#39; + path);
  return false;
}

function getHash() {
  // We can&#39;t use window.location.hash here because it&#39;s not
  // consistent across browsers - Firefox will pre-decode it!
  var href = window.location.href;
  var index = href.indexOf(&#39;#&#39;);
  return index === -1 ? &#39;&#39; : href.slice(index + 1);
}

function pushHash(path) {
  window.location.hash = path;
}

function replaceHash(path) {
  var i = window.location.href.indexOf(&#39;#&#39;);
  window.location.replace(window.location.href.slice(0, i &gt;= 0 ? i : 0) + &#39;#&#39; + path);
}

/*  */

var AbstractHistory = function (History$$1) {
  function AbstractHistory(router, base) {
    History$$1.call(this, router, base);
    this.stack = [];
    this.index = -1;
  }

  if (History$$1) AbstractHistory.__proto__ = History$$1;
  AbstractHistory.prototype = Object.create(History$$1 &amp;&amp; History$$1.prototype);
  AbstractHistory.prototype.constructor = AbstractHistory;

  AbstractHistory.prototype.push = function push(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index + 1).concat(route);
      this$1.index++;
      onComplete &amp;&amp; onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.replace = function replace(location, onComplete, onAbort) {
    var this$1 = this;

    this.transitionTo(location, function (route) {
      this$1.stack = this$1.stack.slice(0, this$1.index).concat(route);
      onComplete &amp;&amp; onComplete(route);
    }, onAbort);
  };

  AbstractHistory.prototype.go = function go(n) {
    var this$1 = this;

    var targetIndex = this.index + n;
    if (targetIndex &lt; 0 || targetIndex &gt;= this.stack.length) {
      return;
    }
    var route = this.stack[targetIndex];
    this.confirmTransition(route, function () {
      this$1.index = targetIndex;
      this$1.updateRoute(route);
    });
  };

  AbstractHistory.prototype.getCurrentLocation = function getCurrentLocation() {
    var current = this.stack[this.stack.length - 1];
    return current ? current.fullPath : &#39;/&#39;;
  };

  AbstractHistory.prototype.ensureURL = function ensureURL() {
    // noop
  };

  return AbstractHistory;
}(History);

/*  */

var VueRouter = function VueRouter(options) {
  if (options === void 0) options = {};

  this.app = null;
  this.apps = [];
  this.options = options;
  this.beforeHooks = [];
  this.resolveHooks = [];
  this.afterHooks = [];
  this.matcher = createMatcher(options.routes || [], this);

  var mode = options.mode || &#39;hash&#39;;
  this.fallback = mode === &#39;history&#39; &amp;&amp; !supportsPushState;
  if (this.fallback) {
    mode = &#39;hash&#39;;
  }
  if (!inBrowser) {
    mode = &#39;abstract&#39;;
  }
  this.mode = mode;

  switch (mode) {
    case &#39;history&#39;:
      this.history = new HTML5History(this, options.base);
      break;
    case &#39;hash&#39;:
      this.history = new HashHistory(this, options.base, this.fallback);
      break;
    case &#39;abstract&#39;:
      this.history = new AbstractHistory(this, options.base);
      break;
    default:
      if (process.env.NODE_ENV !== &#39;production&#39;) {
        assert(false, &quot;invalid mode: &quot; + mode);
      }
  }
};

var prototypeAccessors = { currentRoute: {} };

VueRouter.prototype.match = function match(raw, current, redirectedFrom) {
  return this.matcher.match(raw, current, redirectedFrom);
};

prototypeAccessors.currentRoute.get = function () {
  return this.history &amp;&amp; this.history.current;
};

VueRouter.prototype.init = function init(app /* Vue component instance */) {
  var this$1 = this;

  process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; assert(install.installed, &quot;not installed. Make sure to call `Vue.use(VueRouter)` &quot; + &quot;before creating root instance.&quot;);

  this.apps.push(app);

  // main app already initialized.
  if (this.app) {
    return;
  }

  this.app = app;

  var history = this.history;

  if (history instanceof HTML5History) {
    history.transitionTo(history.getCurrentLocation());
  } else if (history instanceof HashHistory) {
    var setupHashListener = function setupHashListener() {
      history.setupListeners();
    };
    history.transitionTo(history.getCurrentLocation(), setupHashListener, setupHashListener);
  }

  history.listen(function (route) {
    this$1.apps.forEach(function (app) {
      app._route = route;
    });
  });
};

VueRouter.prototype.beforeEach = function beforeEach(fn) {
  return registerHook(this.beforeHooks, fn);
};

VueRouter.prototype.beforeResolve = function beforeResolve(fn) {
  return registerHook(this.resolveHooks, fn);
};

VueRouter.prototype.afterEach = function afterEach(fn) {
  return registerHook(this.afterHooks, fn);
};

VueRouter.prototype.onReady = function onReady(cb, errorCb) {
  this.history.onReady(cb, errorCb);
};

VueRouter.prototype.onError = function onError(errorCb) {
  this.history.onError(errorCb);
};

VueRouter.prototype.push = function push(location, onComplete, onAbort) {
  this.history.push(location, onComplete, onAbort);
};

VueRouter.prototype.replace = function replace(location, onComplete, onAbort) {
  this.history.replace(location, onComplete, onAbort);
};

VueRouter.prototype.go = function go(n) {
  this.history.go(n);
};

VueRouter.prototype.back = function back() {
  this.go(-1);
};

VueRouter.prototype.forward = function forward() {
  this.go(1);
};

VueRouter.prototype.getMatchedComponents = function getMatchedComponents(to) {
  var route = to ? to.matched ? to : this.resolve(to).route : this.currentRoute;
  if (!route) {
    return [];
  }
  return [].concat.apply([], route.matched.map(function (m) {
    return Object.keys(m.components).map(function (key) {
      return m.components[key];
    });
  }));
};

VueRouter.prototype.resolve = function resolve(to, current, append) {
  var location = normalizeLocation(to, current || this.history.current, append, this);
  var route = this.match(location, current);
  var fullPath = route.redirectedFrom || route.fullPath;
  var base = this.history.base;
  var href = createHref(base, fullPath, this.mode);
  return {
    location: location,
    route: route,
    href: href,
    // for backwards compat
    normalizedTo: location,
    resolved: route
  };
};

VueRouter.prototype.addRoutes = function addRoutes(routes) {
  this.matcher.addRoutes(routes);
  if (this.history.current !== START) {
    this.history.transitionTo(this.history.getCurrentLocation());
  }
};

Object.defineProperties(VueRouter.prototype, prototypeAccessors);

function registerHook(list, fn) {
  list.push(fn);
  return function () {
    var i = list.indexOf(fn);
    if (i &gt; -1) {
      list.splice(i, 1);
    }
  };
}

function createHref(base, fullPath, mode) {
  var path = mode === &#39;hash&#39; ? &#39;#&#39; + fullPath : fullPath;
  return base ? cleanPath(base + &#39;/&#39; + path) : path;
}

VueRouter.install = install;
VueRouter.version = &#39;2.5.3&#39;;

if (inBrowser &amp;&amp; window.Vue) {
  window.Vue.use(VueRouter);
}

exports.default = VueRouter;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(6)))

/***/ }),

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(&quot;U6Lg&quot;);

/***/ }),

/***/ 1:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(&quot;OL8Z&quot;);

/***/ }),

/***/ &quot;1nuA&quot;:
/***/ (function(module, exports, __webpack_require__) {

&quot;use strict&quot;;


exports.decode = exports.parse = __webpack_require__(&quot;kMPS&quot;);
exports.encode = exports.stringify = __webpack_require__(&quot;xaZU&quot;);

/***/ }),

/***/ &quot;2qa9&quot;:
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(&quot;VU/8&quot;)(
  /* script */
  __webpack_require__(&quot;WrUb&quot;),
  /* template */
  __webpack_require__(&quot;WnVb&quot;),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = &quot;F:\\source\\static_guojiang_tv\\src\\mobile\\v2\\js\\joinOrg\\getAuthCode.vue&quot;
if (Component.esModule &amp;&amp; Object.keys(Component.esModule).some(function (key) {return key !== &quot;default&quot; &amp;&amp; key !== &quot;__esModule&quot;})) {console.error(&quot;named exports are not supported in *.vue files.&quot;)}
if (Component.options.functional) {console.error(&quot;[vue-loader] getAuthCode.vue: functional components are not supported with templates, they should use render functions.&quot;)}

/* hot reload */
if (false) {(function () {
  var hotAPI = require(&quot;vue-hot-reload-api&quot;)
  hotAPI.install(require(&quot;vue&quot;), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord(&quot;data-v-9be47758&quot;, Component.options)
  } else {
    hotAPI.reload(&quot;data-v-9be47758&quot;, Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),

/***/ &quot;2wU1&quot;:
/***/ (function(module, exports, __webpack_require__) {

&quot;use strict&quot;;


Object.defineProperty(exports, &quot;__esModule&quot;, {
    value: true
});

var _webpackZepto = __webpack_require__(4);

var _webpackZepto2 = _interopRequireDefault(_webpackZepto);

var _common = __webpack_require__(&quot;iKyZ&quot;);

var _common2 = _interopRequireDefault(_common);

var _axios = __webpack_require__(1);

var _axios2 = _interopRequireDefault(_axios);

var _rsa = __webpack_require__(&quot;BseV&quot;);

var _rsa2 = _interopRequireDefault(_rsa);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var rsa = new _rsa2.default.RSA();

var _data = {
    nickname: &#39;&#39;,
    password: &#39;&#39;,
    sex: 0,
    flag: true
};
exports.default = {
    data: function data() {
        return _data;
    },
    props: [&#39;info&#39;],
    methods: {
        showSexHint: function showSexHint() {
            layer.open({
                content: &#39;性别提交后无法再次修改&#39;,
                btn: [&#39;确定&#39;],
                skin: &#39;sex_hint&#39;
            });
        },
        verifyInfo: function verifyInfo() {
            var _this = this;

            //防止连续多次点击
            if (!this.flag) return;

            var verifyResult = this.verifySubmitInfo();
            if (!verifyResult) return;

            this.flag = false;

            _common2.default.showLoading
            //加密密码
            ();var key = &#39;-----BEGIN PUBLIC KEY-----\
                    MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAlEB50IfI83W+jVTTBah1\
                    0Fhz8I\/veaX\/HUXr0h9SS5ZcUzFoT8s9LFbE5wkjTgcuXKDiWkvIEXxNP3uuvc\/\/\
                    5k4zQiH5eLkxJj5oaWbgIKnb\/DR\/ucHbTijt2ZzGwX0hn5AW7rlWgvK6SbuPtI\/y\
                    oXcXnwuB7F77\/KCuF5Sgs2upv9LnAJ9WZGuIglRAKXVVb+gHLF2q\/tSm1dh89TJL\
                    KtMaMx\/iNTQH84NbeFNvoLe3tcq94lenBoYpd8TwdMhvLQrUVU3p8GDBcg2FF2ii\
                    kotH8fs8dIT+zll8TY9SUhKzyYTdyuctcykC+gVUCyn+IQBygjjL1mqCasZ5Jn+o\
                    63CbSVHmwCw5kgfXJvai3zAlqbePLLp+b1MiP7eLZznY\/r8MVesw\/Tz4HyVZ3cHg\
                    Ybgw\/KgkyYKbMf5wcabu14XJR+qUQKrH6hI44G1Hc7iEmByY7pG2R9wM0IbFBbrM\
                    vXCmHVUfWdnAg\/NIB8jmYpKR\/YolI5rpxY6o\/WO0EffzNspF7nzpr3fLFgOEaqtG\
                    aB9Bmqhu5Y8vJBzBH+p1RHa0DixZUVgNBAnsUI1G\/5t2JEwTyc+wCbzBkTS0l3+K\
                    l4SzL3hBQNm7uaEsBv4Nu8QOhAyoCJvUVBVZ+Nr0amcc9n3NVY38y1V5meueZgi8\
                    kn9fnmuFcZqdmwTlJc\/NQcsCAwEAAQ==\
                    -----END PUBLIC KEY-----&#39;;
            rsa.setPublicKey(key);
            var encryptPassword = rsa.encrypt(this.password);

            _axios2.default.get(&#39;/user/mobileRegister&#39;, {
                params: {
                    vcode: this.info.authCode,
                    nickname: this.nickname,
                    sex: this.sex,
                    password: encryptPassword
                }
            }).then(function (res) {
                _this.flag = true;
                _common2.default.hideLoading();
                res = res.data;

                if (res.errno == 0) {
                    _this.showResult();
                } else {
                    layer.open({
                        content: res.msg,
                        skin: &#39;msg&#39;,
                        time: 2
                    });
                }
            });
        },
        verifySubmitInfo: function verifySubmitInfo() {
            this.nickname = (0, _webpackZepto2.default)(&#39;#nickname&#39;).val();
            this.password = (0, _webpackZepto2.default)(&#39;#password&#39;).val();
            this.sex = (0, _webpackZepto2.default)(&#39;input[name=&quot;sex&quot;]:checked&#39;).val();

            if (!this.nickname || this.nickname == &#39;&#39;) {
                layer.open({
                    content: &#39;请设置昵称&#39;,
                    skin: &#39;msg&#39;,
                    time: 3
                });
                (0, _webpackZepto2.default)(&#39;#nickname&#39;).focus();
                return false;
            }

            if (!this.password || this.password == &#39;&#39;) {
                layer.open({
                    content: &#39;请设置密码&#39;,
                    skin: &#39;msg&#39;,
                    time: 3
                });
                (0, _webpackZepto2.default)(&#39;#password&#39;).focus();
                return false;
            }

            if (!this.sex || this.sex == &#39;&#39;) {
                layer.open({
                    content: &#39;请设置性别&#39;,
                    skin: &#39;msg&#39;,
                    time: 3
                });
                return false;
            }

            if (this.nickname.length &lt; 2 || this.nickname.length &gt; 10) {
                layer.open({
                    content: &#39;请输入2-10个字昵称&#39;,
                    skin: &#39;msg&#39;,
                    time: 3
                });
                (0, _webpackZepto2.default)(&#39;#nickname&#39;).focus();
                return false;
            }
            if (this.password.length &lt; 6 || this.password.length &gt; 16) {
                layer.open({
                    content: &#39;请输入6-16位密码&#39;,
                    skin: &#39;msg&#39;,
                    time: 3
                });
                (0, _webpackZepto2.default)(&#39;#password&#39;).focus();
                return false;
            }

            return true;
        },
        showResult: function showResult() {
            router.push(&#39;/bindResult&#39;);
        }
    }
};

/***/ }),

/***/ 6:
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(2))(&quot;W2nU&quot;);

/***/ }),

/***/ &quot;8K/C&quot;:
/***/ (function(module, exports, __webpack_require__) {

&quot;use strict&quot;;


__webpack_require__(&quot;8yG3&quot;);

var _vue = __webpack_require__(0);

var _vue2 = _interopRequireDefault(_vue);

var _vueRouter = __webpack_require__(&quot;/ocq&quot;);

var _vueRouter2 = _interopRequireDefault(_vueRouter);

var _getAuthCode = __webpack_require__(&quot;2qa9&quot;);

var _getAuthCode2 = _interopRequireDefault(_getAuthCode);

var _setProfile = __webpack_require__(&quot;PVZc&quot;);

var _setProfile2 = _interopRequireDefault(_setProfile);

var _bindResult = __webpack_require__(&quot;STya&quot;);

var _bindResult2 = _interopRequireDefault(_bindResult);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

var querystring = __webpack_require__(&quot;1nuA&quot;);

_vue2.default.use(_vueRouter2.default);

var router = new _vueRouter2.default({
    routes: [{ path: &#39;/&#39;, redirect: &#39;/getAuthCode&#39; }, { path: &#39;/getAuthCode&#39;, component: _getAuthCode2.default,
        beforeEnter: function beforeEnter(to, from, next) {
            if (from.path == &#39;/setProfile&#39;) {
                router.go({ &#39;path&#39;: &#39;/&#39;, params: querystring.parse(location.search) });
                return;
            }
            next();
        }
    }, { path: &#39;/setProfile&#39;, component: _setProfile2.default,
        beforeEnter: function beforeEnter(to, from, next) {
            if (from.path == &#39;/bindResult&#39;) {
                router.go({ &#39;path&#39;: &#39;/&#39;, params: querystring.parse(location.search) });
                return;
            }
            next();
        }
    }, {
        path: &#39;/bindResult&#39;,
        component: _bindResult2.default
    }]
});
window.router = router;

new _vue2.default({
    el: &#39;#content&#39;,
    data: {
        info: {
            tel: &#39;&#39;,
            authCode: &#39;&#39;
        }
    },
    router: router
});
//console.log(router)
//router.push(&#39;/getAuthCode&#39;)

/***/ }),

/***/ &quot;8yG3&quot;:
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ &quot;BseV&quot;:
/***/ (function(module, exports, __webpack_require__) {

&quot;use strict&quot;;


var _typeof = typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot; ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj; };

var dbits;
var canary = 244837814094590;
var j_lm = (canary &amp; 16777215) == 15715070;
function BigInteger(a, b, c) {
    if (a != null) {
        if (&quot;number&quot; == typeof a) {
            this.fromNumber(a, b, c);
        } else {
            if (b == null &amp;&amp; &quot;string&quot; != typeof a) {
                this.fromString(a, 256);
            } else {
                this.fromString(a, b);
            }
        }
    }
}
function nbi() {
    return new BigInteger(null);
}
function am1(i, x, w, j, c, n) {
    while (--n &gt;= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 67108864);
        w[j++] = v &amp; 67108863;
    }
    return c;
}
function am2(i, x, w, j, c, n) {
    var xl = x &amp; 32767,
        xh = x &gt;&gt; 15;
    while (--n &gt;= 0) {
        var l = this[i] &amp; 32767;
        var h = this[i++] &gt;&gt; 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m &amp; 32767) &lt;&lt; 15) + w[j] + (c &amp; 1073741823);
        c = (l &gt;&gt;&gt; 30) + (m &gt;&gt;&gt; 15) + xh * h + (c &gt;&gt;&gt; 30);
        w[j++] = l &amp; 1073741823;
    }
    return c;
}
function am3(i, x, w, j, c, n) {
    var xl = x &amp; 16383,
        xh = x &gt;&gt; 14;
    while (--n &gt;= 0) {
        var l = this[i] &amp; 16383;
        var h = this[i++] &gt;&gt; 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m &amp; 16383) &lt;&lt; 14) + w[j] + c;
        c = (l &gt;&gt; 28) + (m &gt;&gt; 14) + xh * h;
        w[j++] = l &amp; 268435455;
    }
    return c;
}
if (j_lm &amp;&amp; navigator.appName == &quot;Microsoft Internet Explorer&quot;) {
    BigInteger.prototype.am = am2;
    dbits = 30;
} else {
    if (j_lm &amp;&amp; navigator.appName != &quot;Netscape&quot;) {
        BigInteger.prototype.am = am1;
        dbits = 26;
    } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
    }
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = (1 &lt;&lt; dbits) - 1;
BigInteger.prototype.DV = 1 &lt;&lt; dbits;
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = &quot;0123456789abcdefghijklmnopqrstuvwxyz&quot;;
var BI_RC = new Array();
var rr, vv;
rr = &quot;0&quot;.charCodeAt(0);
for (vv = 0; vv &lt;= 9; ++vv) {
    BI_RC[rr++] = vv;
}
rr = &quot;a&quot;.charCodeAt(0);
for (vv = 10; vv &lt; 36; ++vv) {
    BI_RC[rr++] = vv;
}
rr = &quot;A&quot;.charCodeAt(0);
for (vv = 10; vv &lt; 36; ++vv) {
    BI_RC[rr++] = vv;
}
function int2char(n) {
    return BI_RM.charAt(n);
}
function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return c == null ? -1 : c;
}
function bnpCopyTo(r) {
    for (var i = this.t - 1; i &gt;= 0; --i) {
        r[i] = this[i];
    }
    r.t = this.t;
    r.s = this.s;
}
function bnpFromInt(x) {
    this.t = 1;
    this.s = x &lt; 0 ? -1 : 0;
    if (x &gt; 0) {
        this[0] = x;
    } else {
        if (x &lt; -1) {
            this[0] = x + DV;
        } else {
            this.t = 0;
        }
    }
}
function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
}
function bnpFromString(s, b) {
    var k;
    if (b == 16) {
        k = 4;
    } else {
        if (b == 8) {
            k = 3;
        } else {
            if (b == 256) {
                k = 8;
            } else {
                if (b == 2) {
                    k = 1;
                } else {
                    if (b == 32) {
                        k = 5;
                    } else {
                        if (b == 4) {
                            k = 2;
                        } else {
                            this.fromRadix(s, b);
                            return;
                        }
                    }
                }
            }
        }
    }
    this.t = 0;
    this.s = 0;
    var i = s.length,
        mi = false,
        sh = 0;
    while (--i &gt;= 0) {
        var x = k == 8 ? s[i] &amp; 255 : intAt(s, i);
        if (x &lt; 0) {
            if (s.charAt(i) == &quot;-&quot;) {
                mi = true;
            }
            continue;
        }
        mi = false;
        if (sh == 0) {
            this[this.t++] = x;
        } else {
            if (sh + k &gt; this.DB) {
                this[this.t - 1] |= (x &amp; (1 &lt;&lt; this.DB - sh) - 1) &lt;&lt; sh;
                this[this.t++] = x &gt;&gt; this.DB - sh;
            } else {
                this[this.t - 1] |= x &lt;&lt; sh;
            }
        }
        sh += k;
        if (sh &gt;= this.DB) {
            sh -= this.DB;
        }
    }
    if (k == 8 &amp;&amp; (s[0] &amp; 128) != 0) {
        this.s = -1;
        if (sh &gt; 0) {
            this[this.t - 1] |= (1 &lt;&lt; this.DB - sh) - 1 &lt;&lt; sh;
        }
    }
    this.clamp();
    if (mi) {
        BigInteger.ZERO.subTo(this, this);
    }
}
function bnpClamp() {
    var c = this.s &amp; this.DM;
    while (this.t &gt; 0 &amp;&amp; this[this.t - 1] == c) {
        --this.t;
    }
}
function bnToString(b) {
    if (this.s &lt; 0) {
        return &quot;-&quot; + this.negate().toString(b);
    }
    var k;
    if (b == 16) {
        k = 4;
    } else {
        if (b == 8) {
            k = 3;
        } else {
            if (b == 2) {
                k = 1;
            } else {
                if (b == 32) {
                    k = 5;
                } else {
                    if (b == 4) {
                        k = 2;
                    } else {
                        return this.toRadix(b);
                    }
                }
            }
        }
    }
    var km = (1 &lt;&lt; k) - 1,
        d,
        m = false,
        r = &quot;&quot;,
        i = this.t;
    var p = this.DB - i * this.DB % k;
    if (i-- &gt; 0) {
        if (p &lt; this.DB &amp;&amp; (d = this[i] &gt;&gt; p) &gt; 0) {
            m = true;
            r = int2char(d);
        }
        while (i &gt;= 0) {
            if (p &lt; k) {
                d = (this[i] &amp; (1 &lt;&lt; p) - 1) &lt;&lt; k - p;
                d |= this[--i] &gt;&gt; (p += this.DB - k);
            } else {
                d = this[i] &gt;&gt; (p -= k) &amp; km;
                if (p &lt;= 0) {
                    p += this.DB;
                    --i;
                }
            }
            if (d &gt; 0) {
                m = true;
            }
            if (m) {
                r += int2char(d);
            }
        }
    }
    return m ? r : &quot;0&quot;;
}
function bnNegate() {
    var r = nbi();
    BigInteger.ZERO.subTo(this, r);
    return r;
}
function bnAbs() {
    return this.s &lt; 0 ? this.negate() : this;
}
function bnCompareTo(a) {
    var r = this.s - a.s;
    if (r != 0) {
        return r;
    }
    var i = this.t;
    r = i - a.t;
    if (r != 0) {
        return this.s &lt; 0 ? -r : r;
    }
    while (--i &gt;= 0) {
        if ((r = this[i] - a[i]) != 0) {
            return r;
        }
    }
    return 0;
}
function nbits(x) {
    var r = 1,
        t;
    if ((t = x &gt;&gt;&gt; 16) != 0) {
        x = t;
        r += 16;
    }
    if ((t = x &gt;&gt; 8) != 0) {
        x = t;
        r += 8;
    }
    if ((t = x &gt;&gt; 4) != 0) {
        x = t;
        r += 4;
    }
    if ((t = x &gt;&gt; 2) != 0) {
        x = t;
        r += 2;
    }
    if ((t = x &gt;&gt; 1) != 0) {
        x = t;
        r += 1;
    }
    return r;
}
function bnBitLength() {
    if (this.t &lt;= 0) {
        return 0;
    }
    return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s &amp; this.DM);
}
function bnpDLShiftTo(n, r) {
    var i;
    for (i = this.t - 1; i &gt;= 0; --i) {
        r[i + n] = this[i];
    }
    for (i = n - 1; i &gt;= 0; --i) {
        r[i] = 0;
    }
    r.t = this.t + n;
    r.s = this.s;
}
function bnpDRShiftTo(n, r) {
    for (var i = n; i &lt; this.t; ++i) {
        r[i - n] = this[i];
    }
    r.t = Math.max(this.t - n, 0);
    r.s = this.s;
}
function bnpLShiftTo(n, r) {
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 &lt;&lt; cbs) - 1;
    var ds = Math.floor(n / this.DB),
        c = this.s &lt;&lt; bs &amp; this.DM,
        i;
    for (i = this.t - 1; i &gt;= 0; --i) {
        r[i + ds + 1] = this[i] &gt;&gt; cbs | c;
        c = (this[i] &amp; bm) &lt;&lt; bs;
    }
    for (i = ds - 1; i &gt;= 0; --i) {
        r[i] = 0;
    }
    r[ds] = c;
    r.t = this.t + ds + 1;
    r.s = this.s;
    r.clamp();
}
function bnpRShiftTo(n, r) {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds &gt;= this.t) {
        r.t = 0;
        return;
    }
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 &lt;&lt; bs) - 1;
    r[0] = this[ds] &gt;&gt; bs;
    for (var i = ds + 1; i &lt; this.t; ++i) {
        r[i - ds - 1] |= (this[i] &amp; bm) &lt;&lt; cbs;
        r[i - ds] = this[i] &gt;&gt; bs;
    }
    if (bs &gt; 0) {
        r[this.t - ds - 1] |= (this.s &amp; bm) &lt;&lt; cbs;
    }
    r.t = this.t - ds;
    r.clamp();
}
function bnpSubTo(a, r) {
    var i = 0,
        c = 0,
        m = Math.min(a.t, this.t);
    while (i &lt; m) {
        c += this[i] - a[i];
        r[i++] = c &amp; this.DM;
        c &gt;&gt;= this.DB;
    }
    if (a.t &lt; this.t) {
        c -= a.s;
        while (i &lt; this.t) {
            c += this[i];
            r[i++] = c &amp; this.DM;
            c &gt;&gt;= this.DB;
        }
        c += this.s;
    } else {
        c += this.s;
        while (i &lt; a.t) {
            c -= a[i];
            r[i++] = c &amp; this.DM;
            c &gt;&gt;= this.DB;
        }
        c -= a.s;
    }
    r.s = c &lt; 0 ? -1 : 0;
    if (c &lt; -1) {
        r[i++] = this.DV + c;
    } else {
        if (c &gt; 0) {
            r[i++] = c;
        }
    }
    r.t = i;
    r.clamp();
}
function bnpMultiplyTo(a, r) {
    var x = this.abs(),
        y = a.abs();
    var i = x.t;
    r.t = i + y.t;
    while (--i &gt;= 0) {
        r[i] = 0;
    }
    for (i = 0; i &lt; y.t; ++i) {
        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
    }
    r.s = 0;
    r.clamp();
    if (this.s != a.s) {
        BigInteger.ZERO.subTo(r, r);
    }
}
function bnpSquareTo(r) {
    var x = this.abs();
    var i = r.t = 2 * x.t;
    while (--i &gt;= 0) {
        r[i] = 0;
    }
    for (i = 0; i &lt; x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) &gt;= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
        }
    }
    if (r.t &gt; 0) {
        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
    }
    r.s = 0;
    r.clamp();
}
function bnpDivRemTo(m, q, r) {
    var pm = m.abs();
    if (pm.t &lt;= 0) {
        return;
    }
    var pt = this.abs();
    if (pt.t &lt; pm.t) {
        if (q != null) {
            q.fromInt(0);
        }
        if (r != null) {
            this.copyTo(r);
        }
        return;
    }
    if (r == null) {
        r = nbi();
    }
    var y = nbi(),
        ts = this.s,
        ms = m.s;
    var nsh = this.DB - nbits(pm[pm.t - 1]);
    if (nsh &gt; 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
    } else {
        pm.copyTo(y);
        pt.copyTo(r);
    }
    var ys = y.t;
    var y0 = y[ys - 1];
    if (y0 == 0) {
        return;
    }
    var yt = y0 * (1 &lt;&lt; this.F1) + (ys &gt; 1 ? y[ys - 2] &gt;&gt; this.F2 : 0);
    var d1 = this.FV / yt,
        d2 = (1 &lt;&lt; this.F1) / yt,
        e = 1 &lt;&lt; this.F2;
    var i = r.t,
        j = i - ys,
        t = q == null ? nbi() : q;
    y.dlShiftTo(j, t);
    if (r.compareTo(t) &gt;= 0) {
        r[r.t++] = 1;
        r.subTo(t, r);
    }
    BigInteger.ONE.dlShiftTo(ys, t);
    t.subTo(y, y);
    while (y.t &lt; ys) {
        y[y.t++] = 0;
    }
    while (--j &gt;= 0) {
        var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) &lt; qd) {
            y.dlShiftTo(j, t);
            r.subTo(t, r);
            while (r[i] &lt; --qd) {
                r.subTo(t, r);
            }
        }
    }
    if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms) {
            BigInteger.ZERO.subTo(q, q);
        }
    }
    r.t = ys;
    r.clamp();
    if (nsh &gt; 0) {
        r.rShiftTo(nsh, r);
    }
    if (ts &lt; 0) {
        BigInteger.ZERO.subTo(r, r);
    }
}
function bnMod(a) {
    var r = nbi();
    this.abs().divRemTo(a, null, r);
    if (this.s &lt; 0 &amp;&amp; r.compareTo(BigInteger.ZERO) &gt; 0) {
        a.subTo(r, r);
    }
    return r;
}
function Classic(m) {
    this.m = m;
}
function cConvert(x) {
    if (x.s &lt; 0 || x.compareTo(this.m) &gt;= 0) {
        return x.mod(this.m);
    } else {
        return x;
    }
}
function cRevert(x) {
    return x;
}
function cReduce(x) {
    x.divRemTo(this.m, null, x);
}
function cMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
}
function cSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
    if (this.t &lt; 1) {
        return 0;
    }
    var x = this[0];
    if ((x &amp; 1) == 0) {
        return 0;
    }
    var y = x &amp; 3;
    y = y * (2 - (x &amp; 15) * y) &amp; 15;
    y = y * (2 - (x &amp; 255) * y) &amp; 255;
    y = y * (2 - ((x &amp; 65535) * y &amp; 65535)) &amp; 65535;
    y = y * (2 - x * y % this.DV) % this.DV;
    return y &gt; 0 ? this.DV - y : -y;
}
function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp &amp; 32767;
    this.mph = this.mp &gt;&gt; 15;
    this.um = (1 &lt;&lt; m.DB - 15) - 1;
    this.mt2 = 2 * m.t;
}
function montConvert(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t, r);
    r.divRemTo(this.m, null, r);
    if (x.s &lt; 0 &amp;&amp; r.compareTo(BigInteger.ZERO) &gt; 0) {
        this.m.subTo(r, r);
    }
    return r;
}
function montRevert(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
}
function montReduce(x) {
    while (x.t &lt;= this.mt2) {
        x[x.t++] = 0;
    }
    for (var i = 0; i &lt; this.m.t; ++i) {
        var j = x[i] &amp; 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x[i] &gt;&gt; 15) * this.mpl &amp; this.um) &lt;&lt; 15) &amp; x.DM;
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x[j] &gt;= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
        }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) &gt;= 0) {
        x.subTo(this.m, x);
    }
}
function montSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
}
function montMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
    return (this.t &gt; 0 ? this[0] &amp; 1 : this.s) == 0;
}
function bnpExp(e, z) {
    if (e &gt; 4294967295 || e &lt; 1) {
        return BigInteger.ONE;
    }
    var r = nbi(),
        r2 = nbi(),
        g = z.convert(this),
        i = nbits(e) - 1;
    g.copyTo(r);
    while (--i &gt;= 0) {
        z.sqrTo(r, r2);
        if ((e &amp; 1 &lt;&lt; i) &gt; 0) {
            z.mulTo(r2, g, r);
        } else {
            var t = r;
            r = r2;
            r2 = t;
        }
    }
    return z.revert(r);
}
function bnModPowInt(e, m) {
    var z;
    if (e &lt; 256 || m.isEven()) {
        z = new Classic(m);
    } else {
        z = new Montgomery(m);
    }
    return this.exp(e, z);
}
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.isEven = bnpIsEven;
BigInteger.prototype.exp = bnpExp;
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.modPowInt = bnModPowInt;
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);
function bnClone() {
    var r = nbi();
    this.copyTo(r);
    return r;
}
function bnIntValue() {
    if (this.s &lt; 0) {
        if (this.t == 1) {
            return this[0] - this.DV;
        } else {
            if (this.t == 0) {
                return -1;
            }
        }
    } else {
        if (this.t == 1) {
            return this[0];
        } else {
            if (this.t == 0) {
                return 0;
            }
        }
    }
    return (this[1] &amp; (1 &lt;&lt; 32 - this.DB) - 1) &lt;&lt; this.DB | this[0];
}
function bnByteValue() {
    return this.t == 0 ? this.s : this[0] &lt;&lt; 24 &gt;&gt; 24;
}
function bnShortValue() {
    return this.t == 0 ? this.s : this[0] &lt;&lt; 16 &gt;&gt; 16;
}
function bnpChunkSize(r) {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
}
function bnSigNum() {
    if (this.s &lt; 0) {
        return -1;
    } else {
        if (this.t &lt;= 0 || this.t == 1 &amp;&amp; this[0] &lt;= 0) {
            return 0;
        } else {
            return 1;
        }
    }
}
function bnpToRadix(b) {
    if (b == null) {
        b = 10;
    }
    if (this.signum() == 0 || b &lt; 2 || b &gt; 36) {
        return &quot;0&quot;;
    }
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a),
        y = nbi(),
        z = nbi(),
        r = &quot;&quot;;
    this.divRemTo(d, y, z);
    while (y.signum() &gt; 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
    }
    return z.intValue().toString(b) + r;
}
function bnpFromRadix(s, b) {
    this.fromInt(0);
    if (b == null) {
        b = 10;
    }
    var cs = this.chunkSize(b);
    var d = Math.pow(b, cs),
        mi = false,
        j = 0,
        w = 0;
    for (var i = 0; i &lt; s.length; ++i) {
        var x = intAt(s, i);
        if (x &lt; 0) {
            if (s.charAt(i) == &quot;-&quot; &amp;&amp; this.signum() == 0) {
                mi = true;
            }
            continue;
        }
        w = b * w + x;
        if (++j &gt;= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
        }
    }
    if (j &gt; 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
    }
    if (mi) {
        BigInteger.ZERO.subTo(this, this);
    }
}
function bnpFromNumber(a, b, c) {
    if (&quot;number&quot; == typeof b) {
        if (a &lt; 2) {
            this.fromInt(1);
        } else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1)) {
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            }
            if (this.isEven()) {
                this.dAddOffset(1, 0);
            }
            while (!this.isProbablePrime(b)) {
                this.dAddOffset(2, 0);
                if (this.bitLength() &gt; a) {
                    this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
                }
            }
        }
    } else {
        var x = new Array(),
            t = a &amp; 7;
        x.length = (a &gt;&gt; 3) + 1;
        b.nextBytes(x);
        if (t &gt; 0) {
            x[0] &amp;= (1 &lt;&lt; t) - 1;
        } else {
            x[0] = 0;
        }
        this.fromString(x, 256);
    }
}
function bnToByteArray() {
    var i = this.t,
        r = new Array();
    r[0] = this.s;
    var p = this.DB - i * this.DB % 8,
        d,
        k = 0;
    if (i-- &gt; 0) {
        if (p &lt; this.DB &amp;&amp; (d = this[i] &gt;&gt; p) != (this.s &amp; this.DM) &gt;&gt; p) {
            r[k++] = d | this.s &lt;&lt; this.DB - p;
        }
        while (i &gt;= 0) {
            if (p &lt; 8) {
                d = (this[i] &amp; (1 &lt;&lt; p) - 1) &lt;&lt; 8 - p;
                d |= this[--i] &gt;&gt; (p += this.DB - 8);
            } else {
                d = this[i] &gt;&gt; (p -= 8) &amp; 255;
                if (p &lt;= 0) {
                    p += this.DB;
                    --i;
                }
            }
            if ((d &amp; 128) != 0) {
                d |= -256;
            }
            if (k == 0 &amp;&amp; (this.s &amp; 128) != (d &amp; 128)) {
                ++k;
            }
            if (k &gt; 0 || d != this.s) {
                r[k++] = d;
            }
        }
    }
    return r;
}
function bnEquals(a) {
    return this.compareTo(a) == 0;
}
function bnMin(a) {
    return this.compareTo(a) &lt; 0 ? this : a;
}
function bnMax(a) {
    return this.compareTo(a) &gt; 0 ? this : a;
}
function bnpBitwiseTo(a, op, r) {
    var i,
        f,
        m = Math.min(a.t, this.t);
    for (i = 0; i &lt; m; ++i) {
        r[i] = op(this[i], a[i]);
    }
    if (a.t &lt; this.t) {
        f = a.s &amp; this.DM;
        for (i = m; i &lt; this.t; ++i) {
            r[i] = op(this[i], f);
        }
        r.t = this.t;
    } else {
        f = this.s &amp; this.DM;
        for (i = m; i &lt; a.t; ++i) {
            r[i] = op(f, a[i]);
        }
        r.t = a.t;
    }
    r.s = op(this.s, a.s);
    r.clamp();
}
function op_and(x, y) {
    return x &amp; y;
}
function bnAnd(a) {
    var r = nbi();
    this.bitwiseTo(a, op_and, r);
    return r;
}
function op_or(x, y) {
    return x | y;
}
function bnOr(a) {
    var r = nbi();
    this.bitwiseTo(a, op_or, r);
    return r;
}
function op_xor(x, y) {
    return x ^ y;
}
function bnXor(a) {
    var r = nbi();
    this.bitwiseTo(a, op_xor, r);
    return r;
}
function op_andnot(x, y) {
    return x &amp; ~y;
}
function bnAndNot(a) {
    var r = nbi();
    this.bitwiseTo(a, op_andnot, r);
    return r;
}
function bnNot() {
    var r = nbi();
    for (var i = 0; i &lt; this.t; ++i) {
        r[i] = this.DM &amp; ~this[i];
    }
    r.t = this.t;
    r.s = ~this.s;
    return r;
}
function bnShiftLeft(n) {
    var r = nbi();
    if (n &lt; 0) {
        this.rShiftTo(-n, r);
    } else {
        this.lShiftTo(n, r);
    }
    return r;
}
function bnShiftRight(n) {
    var r = nbi();
    if (n &lt; 0) {
        this.lShiftTo(-n, r);
    } else {
        this.rShiftTo(n, r);
    }
    return r;
}
function lbit(x) {
    if (x == 0) {
        return -1;
    }
    var r = 0;
    if ((x &amp; 65535) == 0) {
        x &gt;&gt;= 16;
        r += 16;
    }
    if ((x &amp; 255) == 0) {
        x &gt;&gt;= 8;
        r += 8;
    }
    if ((x &amp; 15) == 0) {
        x &gt;&gt;= 4;
        r += 4;
    }
    if ((x &amp; 3) == 0) {
        x &gt;&gt;= 2;
        r += 2;
    }
    if ((x &amp; 1) == 0) {
        ++r;
    }
    return r;
}
function bnGetLowestSetBit() {
    for (var i = 0; i &lt; this.t; ++i) {
        if (this[i] != 0) {
            return i * this.DB + lbit(this[i]);
        }
    }
    if (this.s &lt; 0) {
        return this.t * this.DB;
    }
    return -1;
}
function cbit(x) {
    var r = 0;
    while (x != 0) {
        x &amp;= x - 1;
        ++r;
    }
    return r;
}
function bnBitCount() {
    var r = 0,
        x = this.s &amp; this.DM;
    for (var i = 0; i &lt; this.t; ++i) {
        r += cbit(this[i] ^ x);
    }
    return r;
}
function bnTestBit(n) {
    var j = Math.floor(n / this.DB);
    if (j &gt;= this.t) {
        return this.s != 0;
    }
    return (this[j] &amp; 1 &lt;&lt; n % this.DB) != 0;
}
function bnpChangeBit(n, op) {
    var r = BigInteger.ONE.shiftLeft(n);
    this.bitwiseTo(r, op, r);
    return r;
}
function bnSetBit(n) {
    return this.changeBit(n, op_or);
}
function bnClearBit(n) {
    return this.changeBit(n, op_andnot);
}
function bnFlipBit(n) {
    return this.changeBit(n, op_xor);
}
function bnpAddTo(a, r) {
    var i = 0,
        c = 0,
        m = Math.min(a.t, this.t);
    while (i &lt; m) {
        c += this[i] + a[i];
        r[i++] = c &amp; this.DM;
        c &gt;&gt;= this.DB;
    }
    if (a.t &lt; this.t) {
        c += a.s;
        while (i &lt; this.t) {
            c += this[i];
            r[i++] = c &amp; this.DM;
            c &gt;&gt;= this.DB;
        }
        c += this.s;
    } else {
        c += this.s;
        while (i &lt; a.t) {
            c += a[i];
            r[i++] = c &amp; this.DM;
            c &gt;&gt;= this.DB;
        }
        c += a.s;
    }
    r.s = c &lt; 0 ? -1 : 0;
    if (c &gt; 0) {
        r[i++] = c;
    } else {
        if (c &lt; -1) {
            r[i++] = this.DV + c;
        }
    }
    r.t = i;
    r.clamp();
}
function bnAdd(a) {
    var r = nbi();
    this.addTo(a, r);
    return r;
}
function bnSubtract(a) {
    var r = nbi();
    this.subTo(a, r);
    return r;
}
function bnMultiply(a) {
    var r = nbi();
    this.multiplyTo(a, r);
    return r;
}
function bnSquare() {
    var r = nbi();
    this.squareTo(r);
    return r;
}
function bnDivide(a) {
    var r = nbi();
    this.divRemTo(a, r, null);
    return r;
}
function bnRemainder(a) {
    var r = nbi();
    this.divRemTo(a, null, r);
    return r;
}
function bnDivideAndRemainder(a) {
    var q = nbi(),
        r = nbi();
    this.divRemTo(a, q, r);
    return new Array(q, r);
}
function bnpDMultiply(n) {
    this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
}
function bnpDAddOffset(n, w) {
    if (n == 0) {
        return;
    }
    while (this.t &lt;= w) {
        this[this.t++] = 0;
    }
    this[w] += n;
    while (this[w] &gt;= this.DV) {
        this[w] -= this.DV;
        if (++w &gt;= this.t) {
            this[this.t++] = 0;
        }
        ++this[w];
    }
}
function NullExp() {}
function nNop(x) {
    return x;
}
function nMulTo(x, y, r) {
    x.multiplyTo(y, r);
}
function nSqrTo(x, r) {
    x.squareTo(r);
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;
function bnPow(e) {
    return this.exp(e, new NullExp());
}
function bnpMultiplyLowerTo(a, n, r) {
    var i = Math.min(this.t + a.t, n);
    r.s = 0;
    r.t = i;
    while (i &gt; 0) {
        r[--i] = 0;
    }
    var j;
    for (j = r.t - this.t; i &lt; j; ++i) {
        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
    }
    for (j = Math.min(a.t, n); i &lt; j; ++i) {
        this.am(0, a[i], r, i, 0, n - i);
    }
    r.clamp();
}
function bnpMultiplyUpperTo(a, n, r) {
    --n;
    var i = r.t = this.t + a.t - n;
    r.s = 0;
    while (--i &gt;= 0) {
        r[i] = 0;
    }
    for (i = Math.max(n - this.t, 0); i &lt; a.t; ++i) {
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
    }
    r.clamp();
    r.drShiftTo(1, r);
}
function Barrett(m) {
    this.r2 = nbi();
    this.q3 = nbi();
    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
}
function barrettConvert(x) {
    if (x.s &lt; 0 || x.t &gt; 2 * this.m.t) {
        return x.mod(this.m);
    } else {
        if (x.compareTo(this.m) &lt; 0) {
            return x;
        } else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
        }
    }
}
function barrettRevert(x) {
    return x;
}
function barrettReduce(x) {
    x.drShiftTo(this.m.t - 1, this.r2);
    if (x.t &gt; this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while (x.compareTo(this.r2) &lt; 0) {
        x.dAddOffset(1, this.m.t + 1);
    }
    x.subTo(this.r2, x);
    while (x.compareTo(this.m) &gt;= 0) {
        x.subTo(this.m, x);
    }
}
function barrettSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
}
function barrettMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;
function bnModPow(e, m) {
    var i = e.bitLength(),
        k,
        r = nbv(1),
        z;
    if (i &lt;= 0) {
        return r;
    } else {
        if (i &lt; 18) {
            k = 1;
        } else {
            if (i &lt; 48) {
                k = 3;
            } else {
                if (i &lt; 144) {
                    k = 4;
                } else {
                    if (i &lt; 768) {
                        k = 5;
                    } else {
                        k = 6;
                    }
                }
            }
        }
    }
    if (i &lt; 8) {
        z = new Classic(m);
    } else {
        if (m.isEven()) {
            z = new Barrett(m);
        } else {
            z = new Montgomery(m);
        }
    }
    var g = new Array(),
        n = 3,
        k1 = k - 1,
        km = (1 &lt;&lt; k) - 1;
    g[1] = z.convert(this);
    if (k &gt; 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n &lt;= km) {
            g[n] = nbi();
            z.mulTo(g2, g[n - 2], g[n]);
            n += 2;
        }
    }
    var j = e.t - 1,
        w,
        is1 = true,
        r2 = nbi(),
        t;
    i = nbits(e[j]) - 1;
    while (j &gt;= 0) {
        if (i &gt;= k1) {
            w = e[j] &gt;&gt; i - k1 &amp; km;
        } else {
            w = (e[j] &amp; (1 &lt;&lt; i + 1) - 1) &lt;&lt; k1 - i;
            if (j &gt; 0) {
                w |= e[j - 1] &gt;&gt; this.DB + i - k1;
            }
        }
        n = k;
        while ((w &amp; 1) == 0) {
            w &gt;&gt;= 1;
            --n;
        }
        if ((i -= n) &lt; 0) {
            i += this.DB;
            --j;
        }
        if (is1) {
            g[w].copyTo(r);
            is1 = false;
        } else {
            while (n &gt; 1) {
                z.sqrTo(r, r2);
                z.sqrTo(r2, r);
                n -= 2;
            }
            if (n &gt; 0) {
                z.sqrTo(r, r2);
            } else {
                t = r;
                r = r2;
                r2 = t;
            }
            z.mulTo(r2, g[w], r);
        }
        while (j &gt;= 0 &amp;&amp; (e[j] &amp; 1 &lt;&lt; i) == 0) {
            z.sqrTo(r, r2);
            t = r;
            r = r2;
            r2 = t;
            if (--i &lt; 0) {
                i = this.DB - 1;
                --j;
            }
        }
    }
    return z.revert(r);
}
function bnGCD(a) {
    var x = this.s &lt; 0 ? this.negate() : this.clone();
    var y = a.s &lt; 0 ? a.negate() : a.clone();
    if (x.compareTo(y) &lt; 0) {
        var t = x;
        x = y;
        y = t;
    }
    var i = x.getLowestSetBit(),
        g = y.getLowestSetBit();
    if (g &lt; 0) {
        return x;
    }
    if (i &lt; g) {
        g = i;
    }
    if (g &gt; 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
    }
    while (x.signum() &gt; 0) {
        if ((i = x.getLowestSetBit()) &gt; 0) {
            x.rShiftTo(i, x);
        }
        if ((i = y.getLowestSetBit()) &gt; 0) {
            y.rShiftTo(i, y);
        }
        if (x.compareTo(y) &gt;= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
        } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
        }
    }
    if (g &gt; 0) {
        y.lShiftTo(g, y);
    }
    return y;
}
function bnpModInt(n) {
    if (n &lt;= 0) {
        return 0;
    }
    var d = this.DV % n,
        r = this.s &lt; 0 ? n - 1 : 0;
    if (this.t &gt; 0) {
        if (d == 0) {
            r = this[0] % n;
        } else {
            for (var i = this.t - 1; i &gt;= 0; --i) {
                r = (d * r + this[i]) % n;
            }
        }
    }
    return r;
}
function bnModInverse(m) {
    var ac = m.isEven();
    if (this.isEven() &amp;&amp; ac || m.signum() == 0) {
        return BigInteger.ZERO;
    }
    var u = m.clone(),
        v = this.clone();
    var a = nbv(1),
        b = nbv(0),
        c = nbv(0),
        d = nbv(1);
    while (u.signum() != 0) {
        while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
                if (!a.isEven() || !b.isEven()) {
                    a.addTo(this, a);
                    b.subTo(m, b);
                }
                a.rShiftTo(1, a);
            } else {
                if (!b.isEven()) {
                    b.subTo(m, b);
                }
            }
            b.rShiftTo(1, b);
        }
        while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
                if (!c.isEven() || !d.isEven()) {
                    c.addTo(this, c);
                    d.subTo(m, d);
                }
                c.rShiftTo(1, c);
            } else {
                if (!d.isEven()) {
                    d.subTo(m, d);
                }
            }
            d.rShiftTo(1, d);
        }
        if (u.compareTo(v) &gt;= 0) {
            u.subTo(v, u);
            if (ac) {
                a.subTo(c, a);
            }
            b.subTo(d, b);
        } else {
            v.subTo(u, v);
            if (ac) {
                c.subTo(a, c);
            }
            d.subTo(b, d);
        }
    }
    if (v.compareTo(BigInteger.ONE) != 0) {
        return BigInteger.ZERO;
    }
    if (d.compareTo(m) &gt;= 0) {
        return d.subtract(m);
    }
    if (d.signum() &lt; 0) {
        d.addTo(m, d);
    } else {
        return d;
    }
    if (d.signum() &lt; 0) {
        return d.add(m);
    } else {
        return d;
    }
}
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
var lplim = (1 &lt;&lt; 26) / lowprimes[lowprimes.length - 1];
function bnIsProbablePrime(t) {
    var i,
        x = this.abs();
    if (x.t == 1 &amp;&amp; x[0] &lt;= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i &lt; lowprimes.length; ++i) {
            if (x[0] == lowprimes[i]) {
                return true;
            }
        }
        return false;
    }
    if (x.isEven()) {
        return false;
    }
    i = 1;
    while (i &lt; lowprimes.length) {
        var m = lowprimes[i],
            j = i + 1;
        while (j &lt; lowprimes.length &amp;&amp; m &lt; lplim) {
            m *= lowprimes[j++];
        }
        m = x.modInt(m);
        while (i &lt; j) {
            if (m % lowprimes[i++] == 0) {
                return false;
            }
        }
    }
    return x.millerRabin(t);
}
function bnpMillerRabin(t) {
    var n1 = this.subtract(BigInteger.ONE);
    var k = n1.getLowestSetBit();
    if (k &lt;= 0) {
        return false;
    }
    var r = n1.shiftRight(k);
    t = t + 1 &gt;&gt; 1;
    if (t &gt; lowprimes.length) {
        t = lowprimes.length;
    }
    var a = nbi();
    for (var i = 0; i &lt; t; ++i) {
        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 &amp;&amp; y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ &lt; k &amp;&amp; y.compareTo(n1) != 0) {
                y = y.modPowInt(2, this);
                if (y.compareTo(BigInteger.ONE) == 0) {
                    return false;
                }
            }
            if (y.compareTo(n1) != 0) {
                return false;
            }
        }
    }
    return true;
}
BigInteger.prototype.chunkSize = bnpChunkSize;
BigInteger.prototype.toRadix = bnpToRadix;
BigInteger.prototype.fromRadix = bnpFromRadix;
BigInteger.prototype.fromNumber = bnpFromNumber;
BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger.prototype.changeBit = bnpChangeBit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.dMultiply = bnpDMultiply;
BigInteger.prototype.dAddOffset = bnpDAddOffset;
BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger.prototype.modInt = bnpModInt;
BigInteger.prototype.millerRabin = bnpMillerRabin;
BigInteger.prototype.clone = bnClone;
BigInteger.prototype.intValue = bnIntValue;
BigInteger.prototype.byteValue = bnByteValue;
BigInteger.prototype.shortValue = bnShortValue;
BigInteger.prototype.signum = bnSigNum;
BigInteger.prototype.toByteArray = bnToByteArray;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.min = bnMin;
BigInteger.prototype.max = bnMax;
BigInteger.prototype.and = bnAnd;
BigInteger.prototype.or = bnOr;
BigInteger.prototype.xor = bnXor;
BigInteger.prototype.andNot = bnAndNot;
BigInteger.prototype.not = bnNot;
BigInteger.prototype.shiftLeft = bnShiftLeft;
BigInteger.prototype.shiftRight = bnShiftRight;
BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger.prototype.bitCount = bnBitCount;
BigInteger.prototype.testBit = bnTestBit;
BigInteger.prototype.setBit = bnSetBit;
BigInteger.prototype.clearBit = bnClearBit;
BigInteger.prototype.flipBit = bnFlipBit;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.remainder = bnRemainder;
BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger.prototype.modPow = bnModPow;
BigInteger.prototype.modInverse = bnModInverse;
BigInteger.prototype.pow = bnPow;
BigInteger.prototype.gcd = bnGCD;
BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
BigInteger.prototype.square = bnSquare;
function Arcfour() {
    this.i = 0;
    this.j = 0;
    this.S = new Array();
}
function ARC4init(key) {
    var i, j, t;
    for (i = 0; i &lt; 256; ++i) {
        this.S[i] = i;
    }
    j = 0;
    for (i = 0; i &lt; 256; ++i) {
        j = j + this.S[i] + key[i % key.length] &amp; 255;
        t = this.S[i];
        this.S[i] = this.S[j];
        this.S[j] = t;
    }
    this.i = 0;
    this.j = 0;
}
function ARC4next() {
    var t;
    this.i = this.i + 1 &amp; 255;
    this.j = this.j + this.S[this.i] &amp; 255;
    t = this.S[this.i];
    this.S[this.i] = this.S[this.j];
    this.S[this.j] = t;
    return this.S[t + this.S[this.i] &amp; 255];
}
Arcfour.prototype.init = ARC4init;
Arcfour.prototype.next = ARC4next;
function prng_newstate() {
    return new Arcfour();
}
var rng_psize = 256;
var rng_state;
var rng_pool;
var rng_pptr;
function rng_seed_int(x) {
    rng_pool[rng_pptr++] ^= x &amp; 255;
    rng_pool[rng_pptr++] ^= x &gt;&gt; 8 &amp; 255;
    rng_pool[rng_pptr++] ^= x &gt;&gt; 16 &amp; 255;
    rng_pool[rng_pptr++] ^= x &gt;&gt; 24 &amp; 255;
    if (rng_pptr &gt;= rng_psize) {
        rng_pptr -= rng_psize;
    }
}
function rng_seed_time() {
    rng_seed_int(new Date().getTime());
}
if (rng_pool == null) {
    rng_pool = new Array();
    rng_pptr = 0;
    var t;
    if (navigator.appName == &quot;Netscape&quot; &amp;&amp; navigator.appVersion &lt; &quot;5&quot; &amp;&amp; window.crypto) {
        var z = window.crypto.random(32);
        for (t = 0; t &lt; z.length; ++t) {
            rng_pool[rng_pptr++] = z.charCodeAt(t) &amp; 255;
        }
    }
    while (rng_pptr &lt; rng_psize) {
        t = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t &gt;&gt;&gt; 8;
        rng_pool[rng_pptr++] = t &amp; 255;
    }
    rng_pptr = 0;
    rng_seed_time();
}
function rng_get_byte() {
    if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr &lt; rng_pool.length; ++rng_pptr) {
            rng_pool[rng_pptr] = 0;
        }
        rng_pptr = 0;
    }
    return rng_state.next();
}
function rng_get_bytes(ba) {
    var i;
    for (i = 0; i &lt; ba.length; ++i) {
        ba[i] = rng_get_byte();
    }
}
function SecureRandom() {}
SecureRandom.prototype.nextBytes = rng_get_bytes;
function parseBigInt(str, r) {
    return new BigInteger(str, r);
}
function linebrk(s, n) {
    var ret = &quot;&quot;;
    var i = 0;
    while (i + n &lt; s.length) {
        ret += s.substring(i, i + n) + &quot;\n&quot;;
        i += n;
    }
    return ret + s.substring(i, s.length);
}
function byte2Hex(b) {
    if (b &lt; 16) {
        return &quot;0&quot; + b.toString(16);
    } else {
        return b.toString(16);
    }
}
function pkcs1pad2(s, n) {
    if (n &lt; s.length + 11) {
        console.error(&quot;Message too long for RSA&quot;);
        return null;
    }
    var ba = new Array();
    var i = s.length - 1;
    while (i &gt;= 0 &amp;&amp; n &gt; 0) {
        var c = s.charCodeAt(i--);
        if (c &lt; 128) {
            ba[--n] = c;
        } else {
            if (c &gt; 127 &amp;&amp; c &lt; 2048) {
                ba[--n] = c &amp; 63 | 128;
                ba[--n] = c &gt;&gt; 6 | 192;
            } else {
                ba[--n] = c &amp; 63 | 128;
                ba[--n] = c &gt;&gt; 6 &amp; 63 | 128;
                ba[--n] = c &gt;&gt; 12 | 224;
            }
        }
    }
    ba[--n] = 0;
    var rng = new SecureRandom();
    var x = new Array();
    while (n &gt; 2) {
        x[0] = 0;
        while (x[0] == 0) {
            rng.nextBytes(x);
        }
        ba[--n] = x[0];
    }
    ba[--n] = 2;
    ba[--n] = 0;
    return new BigInteger(ba);
}
function RSAKey() {
    this.n = null;
    this.e = 0;
    this.d = null;
    this.p = null;
    this.q = null;
    this.dmp1 = null;
    this.dmq1 = null;
    this.coeff = null;
}
function RSASetPublic(N, E) {
    if (N != null &amp;&amp; E != null &amp;&amp; N.length &gt; 0 &amp;&amp; E.length &gt; 0) {
        this.n = parseBigInt(N, 16);
        this.e = parseInt(E, 16);
    } else {
        console.error(&quot;Invalid RSA public key&quot;);
    }
}
function RSADoPublic(x) {
    return x.modPowInt(this.e, this.n);
}
function RSAEncrypt(text) {
    var m = pkcs1pad2(text, this.n.bitLength() + 7 &gt;&gt; 3);
    if (m == null) {
        return null;
    }
    var c = this.doPublic(m);
    if (c == null) {
        return null;
    }
    var h = c.toString(16);
    if ((h.length &amp; 1) == 0) {
        return h;
    } else {
        return &quot;0&quot; + h;
    }
}
RSAKey.prototype.doPublic = RSADoPublic;
RSAKey.prototype.setPublic = RSASetPublic;
RSAKey.prototype.encrypt = RSAEncrypt;
function pkcs1unpad2(d, n) {
    var b = d.toByteArray();
    var i = 0;
    while (i &lt; b.length &amp;&amp; b[i] == 0) {
        ++i;
    }
    if (b.length - i != n - 1 || b[i] != 2) {
        return null;
    }
    ++i;
    while (b[i] != 0) {
        if (++i &gt;= b.length) {
            return null;
        }
    }
    var ret = &quot;&quot;;
    while (++i &lt; b.length) {
        var c = b[i] &amp; 255;
        if (c &lt; 128) {
            ret += String.fromCharCode(c);
        } else {
            if (c &gt; 191 &amp;&amp; c &lt; 224) {
                ret += String.fromCharCode((c &amp; 31) &lt;&lt; 6 | b[i + 1] &amp; 63);
                ++i;
            } else {
                ret += String.fromCharCode((c &amp; 15) &lt;&lt; 12 | (b[i + 1] &amp; 63) &lt;&lt; 6 | b[i + 2] &amp; 63);
                i += 2;
            }
        }
    }
    return ret;
}
function RSASetPrivate(N, E, D) {
    if (N != null &amp;&amp; E != null &amp;&amp; N.length &gt; 0 &amp;&amp; E.length &gt; 0) {
        this.n = parseBigInt(N, 16);
        this.e = parseInt(E, 16);
        this.d = parseBigInt(D, 16);
    } else {
        console.error(&quot;Invalid RSA private key&quot;);
    }
}
function RSASetPrivateEx(N, E, D, P, Q, DP, DQ, C) {
    if (N != null &amp;&amp; E != null &amp;&amp; N.length &gt; 0 &amp;&amp; E.length &gt; 0) {
        this.n = parseBigInt(N, 16);
        this.e = parseInt(E, 16);
        this.d = parseBigInt(D, 16);
        this.p = parseBigInt(P, 16);
        this.q = parseBigInt(Q, 16);
        this.dmp1 = parseBigInt(DP, 16);
        this.dmq1 = parseBigInt(DQ, 16);
        this.coeff = parseBigInt(C, 16);
    } else {
        console.error(&quot;Invalid RSA private key&quot;);
    }
}
function RSAGenerate(B, E) {
    var rng = new SecureRandom();
    var qs = B &gt;&gt; 1;
    this.e = parseInt(E, 16);
    var ee = new BigInteger(E, 16);
    for (;;) {
        for (;;) {
            this.p = new BigInteger(B - qs, 1, rng);
            if (this.p.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 &amp;&amp; this.p.isProbablePrime(10)) {
                break;
            }
        }
        for (;;) {
            this.q = new BigInteger(qs, 1, rng);
            if (this.q.subtract(BigInteger.ONE).gcd(ee).compareTo(BigInteger.ONE) == 0 &amp;&amp; this.q.isProbablePrime(10)) {
                break;
            }
        }
        if (this.p.compareTo(this.q) &lt;= 0) {
            var t = this.p;
            this.p = this.q;
            this.q = t;
        }
        var p1 = this.p.subtract(BigInteger.ONE);
        var q1 = this.q.subtract(BigInteger.ONE);
        var phi = p1.multiply(q1);
        if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
            this.n = this.p.multiply(this.q);
            this.d = ee.modInverse(phi);
            this.dmp1 = this.d.mod(p1);
            this.dmq1 = this.d.mod(q1);
            this.coeff = this.q.modInverse(this.p);
            break;
        }
    }
}
function RSADoPrivate(x) {
    if (this.p == null || this.q == null) {
        return x.modPow(this.d, this.n);
    }
    var xp = x.mod(this.p).modPow(this.dmp1, this.p);
    var xq = x.mod(this.q).modPow(this.dmq1, this.q);
    while (xp.compareTo(xq) &lt; 0) {
        xp = xp.add(this.p);
    }
    return xp.subtract(xq).multiply(this.coeff).mod(this.p).multiply(this.q).add(xq);
}
function RSADecrypt(ctext) {
    var c = parseBigInt(ctext, 16);
    var m = this.doPrivate(c);
    if (m == null) {
        return null;
    }
    return pkcs1unpad2(m, this.n.bitLength() + 7 &gt;&gt; 3);
}
RSAKey.prototype.doPrivate = RSADoPrivate;
RSAKey.prototype.setPrivate = RSASetPrivate;
RSAKey.prototype.setPrivateEx = RSASetPrivateEx;
RSAKey.prototype.generate = RSAGenerate;
RSAKey.prototype.decrypt = RSADecrypt;
(function () {
    var RSAGenerateAsync = function RSAGenerateAsync(B, E, callback) {
        var rng = new SecureRandom();
        var qs = B &gt;&gt; 1;
        this.e = parseInt(E, 16);
        var ee = new BigInteger(E, 16);
        var rsa = this;
        var loop1 = function loop1() {
            var loop4 = function loop4() {
                if (rsa.p.compareTo(rsa.q) &lt;= 0) {
                    var t = rsa.p;
                    rsa.p = rsa.q;
                    rsa.q = t;
                }
                var p1 = rsa.p.subtract(BigInteger.ONE);
                var q1 = rsa.q.subtract(BigInteger.ONE);
                var phi = p1.multiply(q1);
                if (phi.gcd(ee).compareTo(BigInteger.ONE) == 0) {
                    rsa.n = rsa.p.multiply(rsa.q);
                    rsa.d = ee.modInverse(phi);
                    rsa.dmp1 = rsa.d.mod(p1);
                    rsa.dmq1 = rsa.d.mod(q1);
                    rsa.coeff = rsa.q.modInverse(rsa.p);
                    setTimeout(function () {
                        callback();
                    }, 0);
                } else {
                    setTimeout(loop1, 0);
                }
            };
            var loop3 = function loop3() {
                rsa.q = nbi();
                rsa.q.fromNumberAsync(qs, 1, rng, function () {
                    rsa.q.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 &amp;&amp; rsa.q.isProbablePrime(10)) {
                            setTimeout(loop4, 0);
                        } else {
                            setTimeout(loop3, 0);
                        }
                    });
                });
            };
            var loop2 = function loop2() {
                rsa.p = nbi();
                rsa.p.fromNumberAsync(B - qs, 1, rng, function () {
                    rsa.p.subtract(BigInteger.ONE).gcda(ee, function (r) {
                        if (r.compareTo(BigInteger.ONE) == 0 &amp;&amp; rsa.p.isProbablePrime(10)) {
                            setTimeout(loop3, 0);
                        } else {
                            setTimeout(loop2, 0);
                        }
                    });
                });
            };
            setTimeout(loop2, 0);
        };
        setTimeout(loop1, 0);
    };
    RSAKey.prototype.generateAsync = RSAGenerateAsync;
    var bnGCDAsync = function bnGCDAsync(a, callback) {
        var x = this.s &lt; 0 ? this.negate() : this.clone();
        var y = a.s &lt; 0 ? a.negate() : a.clone();
        if (x.compareTo(y) &lt; 0) {
            var t = x;
            x = y;
            y = t;
        }
        var i = x.getLowestSetBit(),
            g = y.getLowestSetBit();
        if (g &lt; 0) {
            callback(x);
            return;
        }
        if (i &lt; g) {
            g = i;
        }
        if (g &gt; 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
        }
        var gcda1 = function gcda1() {
            if ((i = x.getLowestSetBit()) &gt; 0) {
                x.rShiftTo(i, x);
            }
            if ((i = y.getLowestSetBit()) &gt; 0) {
                y.rShiftTo(i, y);
            }
            if (x.compareTo(y) &gt;= 0) {
                x.subTo(y, x);
                x.rShiftTo(1, x);
            } else {
                y.subTo(x, y);
                y.rShiftTo(1, y);
            }
            if (!(x.signum() &gt; 0)) {
                if (g &gt; 0) {
                    y.lShiftTo(g, y);
                }
                setTimeout(function () {
                    callback(y);
                }, 0);
            } else {
                setTimeout(gcda1, 0);
            }
        };
        setTimeout(gcda1, 10);
    };
    BigInteger.prototype.gcda = bnGCDAsync;
    var bnpFromNumberAsync = function bnpFromNumberAsync(a, b, c, callback) {
        if (&quot;number&quot; == typeof b) {
            if (a &lt; 2) {
                this.fromInt(1);
            } else {
                this.fromNumber(a, c);
                if (!this.testBit(a - 1)) {
                    this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
                }
                if (this.isEven()) {
                    this.dAddOffset(1, 0);
                }
                var bnp = this;
                var bnpfn1 = function bnpfn1() {
                    bnp.dAddOffset(2, 0);
                    if (bnp.bitLength() &gt; a) {
                        bnp.subTo(BigInteger.ONE.shiftLeft(a - 1), bnp);
                    }
                    if (bnp.isProbablePrime(b)) {
                        setTimeout(function () {
                            callback();
                        }, 0);
                    } else {
                        setTimeout(bnpfn1, 0);
                    }
                };
                setTimeout(bnpfn1, 0);
            }
        } else {
            var x = new Array(),
                t = a &amp; 7;
            x.length = (a &gt;&gt; 3) + 1;
            b.nextBytes(x);
            if (t &gt; 0) {
                x[0] &amp;= (1 &lt;&lt; t) - 1;
            } else {
                x[0] = 0;
            }
            this.fromString(x, 256);
        }
    };
    BigInteger.prototype.fromNumberAsync = bnpFromNumberAsync;
})();
var b64map = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
var b64pad = &quot;=&quot;;
function hex2b64(h) {
    var i;
    var c;
    var ret = &quot;&quot;;
    for (i = 0; i + 3 &lt;= h.length; i += 3) {
        c = parseInt(h.substring(i, i + 3), 16);
        ret += b64map.charAt(c &gt;&gt; 6) + b64map.charAt(c &amp; 63);
    }
    if (i + 1 == h.length) {
        c = parseInt(h.substring(i, i + 1), 16);
        ret += b64map.charAt(c &lt;&lt; 2);
    } else {
        if (i + 2 == h.length) {
            c = parseInt(h.substring(i, i + 2), 16);
            ret += b64map.charAt(c &gt;&gt; 2) + b64map.charAt((c &amp; 3) &lt;&lt; 4);
        }
    }
    while ((ret.length &amp; 3) &gt; 0) {
        ret += b64pad;
    }
    return ret;
}
function b64tohex(s) {
    var ret = &quot;&quot;;
    var i;
    var k = 0;
    var slop;
    for (i = 0; i &lt; s.length; ++i) {
        if (s.charAt(i) == b64pad) {
            break;
        }
        v = b64map.indexOf(s.charAt(i));
        if (v &lt; 0) {
            continue;
        }
        if (k == 0) {
            ret += int2char(v &gt;&gt; 2);
            slop = v &amp; 3;
            k = 1;
        } else {
            if (k == 1) {
                ret += int2char(slop &lt;&lt; 2 | v &gt;&gt; 4);
                slop = v &amp; 15;
                k = 2;
            } else {
                if (k == 2) {
                    ret += int2char(slop);
                    ret += int2char(v &gt;&gt; 2);
                    slop = v &amp; 3;
                    k = 3;
                } else {
                    ret += int2char(slop &lt;&lt; 2 | v &gt;&gt; 4);
                    ret += int2char(v &amp; 15);
                    k = 0;
                }
            }
        }
    }
    if (k == 1) {
        ret += int2char(slop &lt;&lt; 2);
    }
    return ret;
}
function b64toBA(s) {
    var h = b64tohex(s);
    var i;
    var a = new Array();
    for (i = 0; 2 * i &lt; h.length; ++i) {
        a[i] = parseInt(h.substring(2 * i, 2 * i + 2), 16);
    }
    return a;
}
var JSX = JSX || {};
JSX.env = JSX.env || {};
var L = JSX,
    OP = Object.prototype,
    FUNCTION_TOSTRING = &quot;[object Function]&quot;,
    ADD = [&quot;toString&quot;, &quot;valueOf&quot;];
JSX.env.parseUA = function (agent) {
    var numberify = function numberify(s) {
        var c = 0;
        return parseFloat(s.replace(/\./g, function () {
            return c++ == 1 ? &quot;&quot; : &quot;.&quot;;
        }));
    },
        nav = navigator,
        o = {
        ie: 0,
        opera: 0,
        gecko: 0,
        webkit: 0,
        chrome: 0,
        mobile: null,
        air: 0,
        ipad: 0,
        iphone: 0,
        ipod: 0,
        ios: null,
        android: 0,
        webos: 0,
        caja: nav &amp;&amp; nav.cajaVersion,
        secure: false,
        os: null
    },
        ua = agent || navigator &amp;&amp; navigator.userAgent,
        loc = window &amp;&amp; window.location,
        href = loc &amp;&amp; loc.href,
        m;
    o.secure = href &amp;&amp; href.toLowerCase().indexOf(&quot;https&quot;) === 0;
    if (ua) {
        if (/windows|win32/i.test(ua)) {
            o.os = &quot;windows&quot;;
        } else {
            if (/macintosh/i.test(ua)) {
                o.os = &quot;macintosh&quot;;
            } else {
                if (/rhino/i.test(ua)) {
                    o.os = &quot;rhino&quot;;
                }
            }
        }
        if (/KHTML/.test(ua)) {
            o.webkit = 1;
        }
        m = ua.match(/AppleWebKit\/([^\s]*)/);
        if (m &amp;&amp; m[1]) {
            o.webkit = numberify(m[1]);
            if (/ Mobile\//.test(ua)) {
                o.mobile = &quot;Apple&quot;;
                m = ua.match(/OS ([^\s]*)/);
                if (m &amp;&amp; m[1]) {
                    m = numberify(m[1].replace(&quot;_&quot;, &quot;.&quot;));
                }
                o.ios = m;
                o.ipad = o.ipod = o.iphone = 0;
                m = ua.match(/iPad|iPod|iPhone/);
                if (m &amp;&amp; m[0]) {
                    o[m[0].toLowerCase()] = o.ios;
                }
            } else {
                m = ua.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/);
                if (m) {
                    o.mobile = m[0];
                }
                if (/webOS/.test(ua)) {
                    o.mobile = &quot;WebOS&quot;;
                    m = ua.match(/webOS\/([^\s]*);/);
                    if (m &amp;&amp; m[1]) {
                        o.webos = numberify(m[1]);
                    }
                }
                if (/ Android/.test(ua)) {
                    o.mobile = &quot;Android&quot;;
                    m = ua.match(/Android ([^\s]*);/);
                    if (m &amp;&amp; m[1]) {
                        o.android = numberify(m[1]);
                    }
                }
            }
            m = ua.match(/Chrome\/([^\s]*)/);
            if (m &amp;&amp; m[1]) {
                o.chrome = numberify(m[1]);
            } else {
                m = ua.match(/AdobeAIR\/([^\s]*)/);
                if (m) {
                    o.air = m[0];
                }
            }
        }
        if (!o.webkit) {
            m = ua.match(/Opera[\s\/]([^\s]*)/);
            if (m &amp;&amp; m[1]) {
                o.opera = numberify(m[1]);
                m = ua.match(/Version\/([^\s]*)/);
                if (m &amp;&amp; m[1]) {
                    o.opera = numberify(m[1]);
                }
                m = ua.match(/Opera Mini[^;]*/);
                if (m) {
                    o.mobile = m[0];
                }
            } else {
                m = ua.match(/MSIE\s([^;]*)/);
                if (m &amp;&amp; m[1]) {
                    o.ie = numberify(m[1]);
                } else {
                    m = ua.match(/Gecko\/([^\s]*)/);
                    if (m) {
                        o.gecko = 1;
                        m = ua.match(/rv:([^\s\)]*)/);
                        if (m &amp;&amp; m[1]) {
                            o.gecko = numberify(m[1]);
                        }
                    }
                }
            }
        }
    }
    return o;
};
JSX.env.ua = JSX.env.parseUA();
JSX.isFunction = function (o) {
    return typeof o === &quot;function&quot; || OP.toString.apply(o) === FUNCTION_TOSTRING;
};
JSX._IEEnumFix = JSX.env.ua.ie ? function (r, s) {
    var i, fname, f;
    for (i = 0; i &lt; ADD.length; i = i + 1) {
        fname = ADD[i];
        f = s[fname];
        if (L.isFunction(f) &amp;&amp; f != OP[fname]) {
            r[fname] = f;
        }
    }
} : function () {};

JSX.extend = function (subc, superc, overrides) {
    if (!superc || !subc) {
        throw new Error(&quot;extend failed, please check that all dependencies are included.&quot;);
    }
    var F = function F() {},
        i;
    F.prototype = superc.prototype;
    subc.prototype = new F();
    subc.prototype.constructor = subc;
    subc.superclass = superc.prototype;
    if (superc.prototype.constructor == OP.constructor) {
        superc.prototype.constructor = superc;
    }
    if (overrides) {
        for (i in overrides) {
            if (L.hasOwnProperty(overrides, i)) {
                subc.prototype[i] = overrides[i];
            }
        }
        L._IEEnumFix(subc.prototype, overrides);
    }
};
if (typeof KJUR == &quot;undefined&quot; || !KJUR) {
    var KJUR = {};
}
if (typeof KJUR.asn1 == &quot;undefined&quot; || !KJUR.asn1) {
    KJUR.asn1 = {};
}
KJUR.asn1.ASN1Util = new function () {
    this.integerToByteHex = function (i) {
        var h = i.toString(16);
        if (h.length % 2 == 1) {
            h = &quot;0&quot; + h;
        }
        return h;
    };
    this.bigIntToMinTwosComplementsHex = function (bigIntegerValue) {
        var h = bigIntegerValue.toString(16);
        if (h.substr(0, 1) != &quot;-&quot;) {
            if (h.length % 2 == 1) {
                h = &quot;0&quot; + h;
            } else {
                if (!h.match(/^[0-7]/)) {
                    h = &quot;00&quot; + h;
                }
            }
        } else {
            var hPos = h.substr(1);
            var xorLen = hPos.length;
            if (xorLen % 2 == 1) {
                xorLen += 1;
            } else {
                if (!h.match(/^[0-7]/)) {
                    xorLen += 2;
                }
            }
            var hMask = &quot;&quot;;
            for (var i = 0; i &lt; xorLen; i++) {
                hMask += &quot;f&quot;;
            }
            var biMask = new BigInteger(hMask, 16);
            var biNeg = biMask.xor(bigIntegerValue).add(BigInteger.ONE);
            h = biNeg.toString(16).replace(/^-/, &quot;&quot;);
        }
        return h;
    };
    this.getPEMStringFromHex = function (dataHex, pemHeader) {
        var dataWA = CryptoJS.enc.Hex.parse(dataHex);
        var dataB64 = CryptoJS.enc.Base64.stringify(dataWA);
        var pemBody = dataB64.replace(/(.{64})/g, &quot;$1\r\n&quot;);
        pemBody = pemBody.replace(/\r\n$/, &quot;&quot;);
        return &quot;-----BEGIN &quot; + pemHeader + &quot;-----\r\n&quot; + pemBody + &quot;\r\n-----END &quot; + pemHeader + &quot;-----\r\n&quot;;
    };
}();
KJUR.asn1.ASN1Object = function () {
    var isModified = true;
    var hTLV = null;
    var hT = &quot;00&quot;;
    var hL = &quot;00&quot;;
    var hV = &quot;&quot;;
    this.getLengthHexFromValue = function () {
        if (typeof this.hV == &quot;undefined&quot; || this.hV == null) {
            throw &quot;this.hV is null or undefined.&quot;;
        }
        if (this.hV.length % 2 == 1) {
            throw &quot;value hex must be even length: n=&quot; + hV.length + &quot;,v=&quot; + this.hV;
        }
        var n = this.hV.length / 2;
        var hN = n.toString(16);
        if (hN.length % 2 == 1) {
            hN = &quot;0&quot; + hN;
        }
        if (n &lt; 128) {
            return hN;
        } else {
            var hNlen = hN.length / 2;
            if (hNlen &gt; 15) {
                throw &quot;ASN.1 length too long to represent by 8x: n = &quot; + n.toString(16);
            }
            var head = 128 + hNlen;
            return head.toString(16) + hN;
        }
    };
    this.getEncodedHex = function () {
        if (this.hTLV == null || this.isModified) {
            this.hV = this.getFreshValueHex();
            this.hL = this.getLengthHexFromValue();
            this.hTLV = this.hT + this.hL + this.hV;
            this.isModified = false;
        }
        return this.hTLV;
    };
    this.getValueHex = function () {
        this.getEncodedHex();
        return this.hV;
    };
    this.getFreshValueHex = function () {
        return &quot;&quot;;
    };
};
KJUR.asn1.DERAbstractString = function (params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
    var s = null;
    var hV = null;
    this.getString = function () {
        return this.s;
    };
    this.setString = function (newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(this.s);
    };
    this.setStringHex = function (newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != &quot;undefined&quot;) {
        if (typeof params.str != &quot;undefined&quot;) {
            this.setString(params.str);
        } else {
            if (typeof params.hex != &quot;undefined&quot;) {
                this.setStringHex(params.hex);
            }
        }
    }
};
JSX.extend(KJUR.asn1.DERAbstractString, KJUR.asn1.ASN1Object);
KJUR.asn1.DERAbstractTime = function (params) {
    KJUR.asn1.DERAbstractTime.superclass.constructor.call(this);
    var s = null;
    var date = null;
    this.localDateToUTC = function (d) {
        utc = d.getTime() + d.getTimezoneOffset() * 60000;
        var utcDate = new Date(utc);
        return utcDate;
    };
    this.formatDate = function (dateObject, type) {
        var pad = this.zeroPadding;
        var d = this.localDateToUTC(dateObject);
        var year = String(d.getFullYear());
        if (type == &quot;utc&quot;) {
            year = year.substr(2, 2);
        }
        var month = pad(String(d.getMonth() + 1), 2);
        var day = pad(String(d.getDate()), 2);
        var hour = pad(String(d.getHours()), 2);
        var min = pad(String(d.getMinutes()), 2);
        var sec = pad(String(d.getSeconds()), 2);
        return year + month + day + hour + min + sec + &quot;Z&quot;;
    };
    this.zeroPadding = function (s, len) {
        if (s.length &gt;= len) {
            return s;
        }
        return new Array(len - s.length + 1).join(&quot;0&quot;) + s;
    };
    this.getString = function () {
        return this.s;
    };
    this.setString = function (newS) {
        this.hTLV = null;
        this.isModified = true;
        this.s = newS;
        this.hV = stohex(this.s);
    };
    this.setByDateValue = function (year, month, day, hour, min, sec) {
        var dateObject = new Date(Date.UTC(year, month - 1, day, hour, min, sec, 0));
        this.setByDate(dateObject);
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
};
JSX.extend(KJUR.asn1.DERAbstractTime, KJUR.asn1.ASN1Object);
KJUR.asn1.DERAbstractStructured = function (params) {
    KJUR.asn1.DERAbstractString.superclass.constructor.call(this);
    var asn1Array = null;
    this.setByASN1ObjectArray = function (asn1ObjectArray) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array = asn1ObjectArray;
    };
    this.appendASN1Object = function (asn1Object) {
        this.hTLV = null;
        this.isModified = true;
        this.asn1Array.push(asn1Object);
    };
    this.asn1Array = new Array();
    if (typeof params != &quot;undefined&quot;) {
        if (typeof params.array != &quot;undefined&quot;) {
            this.asn1Array = params.array;
        }
    }
};
JSX.extend(KJUR.asn1.DERAbstractStructured, KJUR.asn1.ASN1Object);
KJUR.asn1.DERBoolean = function () {
    KJUR.asn1.DERBoolean.superclass.constructor.call(this);
    this.hT = &quot;01&quot;;
    this.hTLV = &quot;0101ff&quot;;
};
JSX.extend(KJUR.asn1.DERBoolean, KJUR.asn1.ASN1Object);
KJUR.asn1.DERInteger = function (params) {
    KJUR.asn1.DERInteger.superclass.constructor.call(this);
    this.hT = &quot;02&quot;;
    this.setByBigInteger = function (bigIntegerValue) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = KJUR.asn1.ASN1Util.bigIntToMinTwosComplementsHex(bigIntegerValue);
    };
    this.setByInteger = function (intValue) {
        var bi = new BigInteger(String(intValue), 10);
        this.setByBigInteger(bi);
    };
    this.setValueHex = function (newHexString) {
        this.hV = newHexString;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != &quot;undefined&quot;) {
        if (typeof params.bigint != &quot;undefined&quot;) {
            this.setByBigInteger(params.bigint);
        } else {
            if (typeof params[&quot;int&quot;] != &quot;undefined&quot;) {
                this.setByInteger(params[&quot;int&quot;]);
            } else {
                if (typeof params.hex != &quot;undefined&quot;) {
                    this.setValueHex(params.hex);
                }
            }
        }
    }
};
JSX.extend(KJUR.asn1.DERInteger, KJUR.asn1.ASN1Object);
KJUR.asn1.DERBitString = function (params) {
    KJUR.asn1.DERBitString.superclass.constructor.call(this);
    this.hT = &quot;03&quot;;
    this.setHexValueIncludingUnusedBits = function (newHexStringIncludingUnusedBits) {
        this.hTLV = null;
        this.isModified = true;
        this.hV = newHexStringIncludingUnusedBits;
    };
    this.setUnusedBitsAndHexValue = function (unusedBits, hValue) {
        if (unusedBits &lt; 0 || 7 &lt; unusedBits) {
            throw &quot;unused bits shall be from 0 to 7: u = &quot; + unusedBits;
        }
        var hUnusedBits = &quot;0&quot; + unusedBits;
        this.hTLV = null;
        this.isModified = true;
        this.hV = hUnusedBits + hValue;
    };
    this.setByBinaryString = function (binaryString) {
        binaryString = binaryString.replace(/0+$/, &quot;&quot;);
        var unusedBits = 8 - binaryString.length % 8;
        if (unusedBits == 8) {
            unusedBits = 0;
        }
        for (var i = 0; i &lt;= unusedBits; i++) {
            binaryString += &quot;0&quot;;
        }
        var h = &quot;&quot;;
        for (var i = 0; i &lt; binaryString.length - 1; i += 8) {
            var b = binaryString.substr(i, 8);
            var x = parseInt(b, 2).toString(16);
            if (x.length == 1) {
                x = &quot;0&quot; + x;
            }
            h += x;
        }
        this.hTLV = null;
        this.isModified = true;
        this.hV = &quot;0&quot; + unusedBits + h;
    };
    this.setByBooleanArray = function (booleanArray) {
        var s = &quot;&quot;;
        for (var i = 0; i &lt; booleanArray.length; i++) {
            if (booleanArray[i] == true) {
                s += &quot;1&quot;;
            } else {
                s += &quot;0&quot;;
            }
        }
        this.setByBinaryString(s);
    };
    this.newFalseArray = function (nLength) {
        var a = new Array(nLength);
        for (var i = 0; i &lt; nLength; i++) {
            a[i] = false;
        }
        return a;
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != &quot;undefined&quot;) {
        if (typeof params.hex != &quot;undefined&quot;) {
            this.setHexValueIncludingUnusedBits(params.hex);
        } else {
            if (typeof params.bin != &quot;undefined&quot;) {
                this.setByBinaryString(params.bin);
            } else {
                if (typeof params.array != &quot;undefined&quot;) {
                    this.setByBooleanArray(params.array);
                }
            }
        }
    }
};
JSX.extend(KJUR.asn1.DERBitString, KJUR.asn1.ASN1Object);
KJUR.asn1.DEROctetString = function (params) {
    KJUR.asn1.DEROctetString.superclass.constructor.call(this, params);
    this.hT = &quot;04&quot;;
};
JSX.extend(KJUR.asn1.DEROctetString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERNull = function () {
    KJUR.asn1.DERNull.superclass.constructor.call(this);
    this.hT = &quot;05&quot;;
    this.hTLV = &quot;0500&quot;;
};
JSX.extend(KJUR.asn1.DERNull, KJUR.asn1.ASN1Object);
KJUR.asn1.DERObjectIdentifier = function (params) {
    var itox = function itox(i) {
        var h = i.toString(16);
        if (h.length == 1) {
            h = &quot;0&quot; + h;
        }
        return h;
    };
    var roidtox = function roidtox(roid) {
        var h = &quot;&quot;;
        var bi = new BigInteger(roid, 10);
        var b = bi.toString(2);
        var padLen = 7 - b.length % 7;
        if (padLen == 7) {
            padLen = 0;
        }
        var bPad = &quot;&quot;;
        for (var i = 0; i &lt; padLen; i++) {
            bPad += &quot;0&quot;;
        }
        b = bPad + b;
        for (var i = 0; i &lt; b.length - 1; i += 7) {
            var b8 = b.substr(i, 7);
            if (i != b.length - 7) {
                b8 = &quot;1&quot; + b8;
            }
            h += itox(parseInt(b8, 2));
        }
        return h;
    };
    KJUR.asn1.DERObjectIdentifier.superclass.constructor.call(this);
    this.hT = &quot;06&quot;;
    this.setValueHex = function (newHexString) {
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = newHexString;
    };
    this.setValueOidString = function (oidString) {
        if (!oidString.match(/^[0-9.]+$/)) {
            throw &quot;malformed oid string: &quot; + oidString;
        }
        var h = &quot;&quot;;
        var a = oidString.split(&quot;.&quot;);
        var i0 = parseInt(a[0]) * 40 + parseInt(a[1]);
        h += itox(i0);
        a.splice(0, 2);
        for (var i = 0; i &lt; a.length; i++) {
            h += roidtox(a[i]);
        }
        this.hTLV = null;
        this.isModified = true;
        this.s = null;
        this.hV = h;
    };
    this.setValueName = function (oidName) {
        if (typeof KJUR.asn1.x509.OID.name2oidList[oidName] != &quot;undefined&quot;) {
            var oid = KJUR.asn1.x509.OID.name2oidList[oidName];
            this.setValueOidString(oid);
        } else {
            throw &quot;DERObjectIdentifier oidName undefined: &quot; + oidName;
        }
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != &quot;undefined&quot;) {
        if (typeof params.oid != &quot;undefined&quot;) {
            this.setValueOidString(params.oid);
        } else {
            if (typeof params.hex != &quot;undefined&quot;) {
                this.setValueHex(params.hex);
            } else {
                if (typeof params.name != &quot;undefined&quot;) {
                    this.setValueName(params.name);
                }
            }
        }
    }
};
JSX.extend(KJUR.asn1.DERObjectIdentifier, KJUR.asn1.ASN1Object);
KJUR.asn1.DERUTF8String = function (params) {
    KJUR.asn1.DERUTF8String.superclass.constructor.call(this, params);
    this.hT = &quot;0c&quot;;
};
JSX.extend(KJUR.asn1.DERUTF8String, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERNumericString = function (params) {
    KJUR.asn1.DERNumericString.superclass.constructor.call(this, params);
    this.hT = &quot;12&quot;;
};
JSX.extend(KJUR.asn1.DERNumericString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERPrintableString = function (params) {
    KJUR.asn1.DERPrintableString.superclass.constructor.call(this, params);
    this.hT = &quot;13&quot;;
};
JSX.extend(KJUR.asn1.DERPrintableString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERTeletexString = function (params) {
    KJUR.asn1.DERTeletexString.superclass.constructor.call(this, params);
    this.hT = &quot;14&quot;;
};
JSX.extend(KJUR.asn1.DERTeletexString, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERIA5String = function (params) {
    KJUR.asn1.DERIA5String.superclass.constructor.call(this, params);
    this.hT = &quot;16&quot;;
};
JSX.extend(KJUR.asn1.DERIA5String, KJUR.asn1.DERAbstractString);
KJUR.asn1.DERUTCTime = function (params) {
    KJUR.asn1.DERUTCTime.superclass.constructor.call(this, params);
    this.hT = &quot;17&quot;;
    this.setByDate = function (dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, &quot;utc&quot;);
        this.hV = stohex(this.s);
    };
    if (typeof params != &quot;undefined&quot;) {
        if (typeof params.str != &quot;undefined&quot;) {
            this.setString(params.str);
        } else {
            if (typeof params.hex != &quot;undefined&quot;) {
                this.setStringHex(params.hex);
            } else {
                if (typeof params.date != &quot;undefined&quot;) {
                    this.setByDate(params.date);
                }
            }
        }
    }
};
JSX.extend(KJUR.asn1.DERUTCTime, KJUR.asn1.DERAbstractTime);
KJUR.asn1.DERGeneralizedTime = function (params) {
    KJUR.asn1.DERGeneralizedTime.superclass.constructor.call(this, params);
    this.hT = &quot;18&quot;;
    this.setByDate = function (dateObject) {
        this.hTLV = null;
        this.isModified = true;
        this.date = dateObject;
        this.s = this.formatDate(this.date, &quot;gen&quot;);
        this.hV = stohex(this.s);
    };
    if (typeof params != &quot;undefined&quot;) {
        if (typeof params.str != &quot;undefined&quot;) {
            this.setString(params.str);
        } else {
            if (typeof params.hex != &quot;undefined&quot;) {
                this.setStringHex(params.hex);
            } else {
                if (typeof params.date != &quot;undefined&quot;) {
                    this.setByDate(params.date);
                }
            }
        }
    }
};
JSX.extend(KJUR.asn1.DERGeneralizedTime, KJUR.asn1.DERAbstractTime);
KJUR.asn1.DERSequence = function (params) {
    KJUR.asn1.DERSequence.superclass.constructor.call(this, params);
    this.hT = &quot;30&quot;;
    this.getFreshValueHex = function () {
        var h = &quot;&quot;;
        for (var i = 0; i &lt; this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            h += asn1Obj.getEncodedHex();
        }
        this.hV = h;
        return this.hV;
    };
};
JSX.extend(KJUR.asn1.DERSequence, KJUR.asn1.DERAbstractStructured);
KJUR.asn1.DERSet = function (params) {
    KJUR.asn1.DERSet.superclass.constructor.call(this, params);
    this.hT = &quot;31&quot;;
    this.getFreshValueHex = function () {
        var a = new Array();
        for (var i = 0; i &lt; this.asn1Array.length; i++) {
            var asn1Obj = this.asn1Array[i];
            a.push(asn1Obj.getEncodedHex());
        }
        a.sort();
        this.hV = a.join(&quot;&quot;);
        return this.hV;
    };
};
JSX.extend(KJUR.asn1.DERSet, KJUR.asn1.DERAbstractStructured);
KJUR.asn1.DERTaggedObject = function (params) {
    KJUR.asn1.DERTaggedObject.superclass.constructor.call(this);
    this.hT = &quot;a0&quot;;
    this.hV = &quot;&quot;;
    this.isExplicit = true;
    this.asn1Object = null;
    this.setASN1Object = function (isExplicitFlag, tagNoHex, asn1Object) {
        this.hT = tagNoHex;
        this.isExplicit = isExplicitFlag;
        this.asn1Object = asn1Object;
        if (this.isExplicit) {
            this.hV = this.asn1Object.getEncodedHex();
            this.hTLV = null;
            this.isModified = true;
        } else {
            this.hV = null;
            this.hTLV = asn1Object.getEncodedHex();
            this.hTLV = this.hTLV.replace(/^../, tagNoHex);
            this.isModified = false;
        }
    };
    this.getFreshValueHex = function () {
        return this.hV;
    };
    if (typeof params != &quot;undefined&quot;) {
        if (typeof params.tag != &quot;undefined&quot;) {
            this.hT = params.tag;
        }
        if (typeof params.explicit != &quot;undefined&quot;) {
            this.isExplicit = params.explicit;
        }
        if (typeof params.obj != &quot;undefined&quot;) {
            this.asn1Object = params.obj;
            this.setASN1Object(this.isExplicit, this.hT, this.asn1Object);
        }
    }
};
JSX.extend(KJUR.asn1.DERTaggedObject, KJUR.asn1.ASN1Object);
(function (undefined) {
    var Hex = {},
        decoder;
    Hex.decode = function (a) {
        var i;
        if (decoder === undefined) {
            var hex = &quot;0123456789ABCDEF&quot;,
                ignore = &quot; \f\n\r\t\xA0\u2028\u2029&quot;;
            decoder = [];
            for (i = 0; i &lt; 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            hex = hex.toLowerCase();
            for (i = 10; i &lt; 16; ++i) {
                decoder[hex.charAt(i)] = i;
            }
            for (i = 0; i &lt; ignore.length; ++i) {
                decoder[ignore.charAt(i)] = -1;
            }
        }
        var out = [],
            bits = 0,
            char_count = 0;
        for (i = 0; i &lt; a.length; ++i) {
            var c = a.charAt(i);
            if (c == &quot;=&quot;) {
                break;
            }
            c = decoder[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw &quot;Illegal character at offset &quot; + i;
            }
            bits |= c;
            if (++char_count &gt;= 2) {
                out[out.length] = bits;
                bits = 0;
                char_count = 0;
            } else {
                bits &lt;&lt;= 4;
            }
        }
        if (char_count) {
            throw &quot;Hex encoding incomplete: 4 bits missing&quot;;
        }
        return out;
    };
    window.Hex = Hex;
})();
(function (undefined) {
    var Base64 = {},
        decoder;
    Base64.decode = function (a) {
        var i;
        if (decoder === undefined) {
            var b64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;,
                ignore = &quot;= \f\n\r\t\xA0\u2028\u2029&quot;;
            decoder = [];
            for (i = 0; i &lt; 64; ++i) {
                decoder[b64.charAt(i)] = i;
            }
            for (i = 0; i &lt; ignore.length; ++i) {
                decoder[ignore.charAt(i)] = -1;
            }
        }
        var out = [];
        var bits = 0,
            char_count = 0;
        for (i = 0; i &lt; a.length; ++i) {
            var c = a.charAt(i);
            if (c == &quot;=&quot;) {
                break;
            }
            c = decoder[c];
            if (c == -1) {
                continue;
            }
            if (c === undefined) {
                throw &quot;Illegal character at offset &quot; + i;
            }
            bits |= c;
            if (++char_count &gt;= 4) {
                out[out.length] = bits &gt;&gt; 16;
                out[out.length] = bits &gt;&gt; 8 &amp; 255;
                out[out.length] = bits &amp; 255;
                bits = 0;
                char_count = 0;
            } else {
                bits &lt;&lt;= 6;
            }
        }
        switch (char_count) {
            case 1:
                throw &quot;Base64 encoding incomplete: at least 2 bits missing&quot;;
            case 2:
                out[out.length] = bits &gt;&gt; 10;
                break;
            case 3:
                out[out.length] = bits &gt;&gt; 16;
                out[out.length] = bits &gt;&gt; 8 &amp; 255;
                break;
        }
        return out;
    };
    Base64.re = /-----BEGIN [^-]+-----([A-Za-z0-9+\/=\s]+)-----END [^-]+-----|begin-base64[^\n]+\n([A-Za-z0-9+\/=\s]+)====/;
    Base64.unarmor = function (a) {
        var m = Base64.re.exec(a);
        if (m) {
            if (m[1]) {
                a = m[1];
            } else {
                if (m[2]) {
                    a = m[2];
                } else {
                    throw &quot;RegExp out of sync&quot;;
                }
            }
        }
        return Base64.decode(a);
    };
    window.Base64 = Base64;
})();
(function (undefined) {
    var hardLimit = 100,
        ellipsis = &quot;\u2026&quot;,
        DOM = {
        tag: function tag(tagName, className) {
            var t = document.createElement(tagName);
            t.className = className;
            return t;
        },
        text: function text(str) {
            return document.createTextNode(str);
        }
    };
    function Stream(enc, pos) {
        if (enc instanceof Stream) {
            this.enc = enc.enc;
            this.pos = enc.pos;
        } else {
            this.enc = enc;
            this.pos = pos;
        }
    }
    Stream.prototype.get = function (pos) {
        if (pos === undefined) {
            pos = this.pos++;
        }
        if (pos &gt;= this.enc.length) {
            throw &quot;Requesting byte offset &quot; + pos + &quot; on a stream of length &quot; + this.enc.length;
        }
        return this.enc[pos];
    };
    Stream.prototype.hexDigits = &quot;0123456789ABCDEF&quot;;
    Stream.prototype.hexByte = function (b) {
        return this.hexDigits.charAt(b &gt;&gt; 4 &amp; 15) + this.hexDigits.charAt(b &amp; 15);
    };
    Stream.prototype.hexDump = function (start, end, raw) {
        var s = &quot;&quot;;
        for (var i = start; i &lt; end; ++i) {
            s += this.hexByte(this.get(i));
            if (raw !== true) {
                switch (i &amp; 15) {
                    case 7:
                        s += &quot;  &quot;;
                        break;
                    case 15:
                        s += &quot;\n&quot;;
                        break;
                    default:
                        s += &quot; &quot;;
                }
            }
        }
        return s;
    };
    Stream.prototype.parseStringISO = function (start, end) {
        var s = &quot;&quot;;
        for (var i = start; i &lt; end; ++i) {
            s += String.fromCharCode(this.get(i));
        }
        return s;
    };
    Stream.prototype.parseStringUTF = function (start, end) {
        var s = &quot;&quot;;
        for (var i = start; i &lt; end;) {
            var c = this.get(i++);
            if (c &lt; 128) {
                s += String.fromCharCode(c);
            } else {
                if (c &gt; 191 &amp;&amp; c &lt; 224) {
                    s += String.fromCharCode((c &amp; 31) &lt;&lt; 6 | this.get(i++) &amp; 63);
                } else {
                    s += String.fromCharCode((c &amp; 15) &lt;&lt; 12 | (this.get(i++) &amp; 63) &lt;&lt; 6 | this.get(i++) &amp; 63);
                }
            }
        }
        return s;
    };
    Stream.prototype.parseStringBMP = function (start, end) {
        var str = &quot;&quot;;
        for (var i = start; i &lt; end; i += 2) {
            var high_byte = this.get(i);
            var low_byte = this.get(i + 1);
            str += String.fromCharCode((high_byte &lt;&lt; 8) + low_byte);
        }
        return str;
    };
    Stream.prototype.reTime = /^((?:1[89]|2\d)?\d\d)(0[1-9]|1[0-2])(0[1-9]|[12]\d|3[01])([01]\d|2[0-3])(?:([0-5]\d)(?:([0-5]\d)(?:[.,](\d{1,3}))?)?)?(Z|[-+](?:[0]\d|1[0-2])([0-5]\d)?)?$/;
    Stream.prototype.parseTime = function (start, end) {
        var s = this.parseStringISO(start, end),
            m = this.reTime.exec(s);
        if (!m) {
            return &quot;Unrecognized time: &quot; + s;
        }
        s = m[1] + &quot;-&quot; + m[2] + &quot;-&quot; + m[3] + &quot; &quot; + m[4];
        if (m[5]) {
            s += &quot;:&quot; + m[5];
            if (m[6]) {
                s += &quot;:&quot; + m[6];
                if (m[7]) {
                    s += &quot;.&quot; + m[7];
                }
            }
        }
        if (m[8]) {
            s += &quot; UTC&quot;;
            if (m[8] != &quot;Z&quot;) {
                s += m[8];
                if (m[9]) {
                    s += &quot;:&quot; + m[9];
                }
            }
        }
        return s;
    };
    Stream.prototype.parseInteger = function (start, end) {
        var len = end - start;
        if (len &gt; 4) {
            len &lt;&lt;= 3;
            var s = this.get(start);
            if (s === 0) {
                len -= 8;
            } else {
                while (s &lt; 128) {
                    s &lt;&lt;= 1;
                    --len;
                }
            }
            return &quot;(&quot; + len + &quot; bit)&quot;;
        }
        var n = 0;
        for (var i = start; i &lt; end; ++i) {
            n = n &lt;&lt; 8 | this.get(i);
        }
        return n;
    };
    Stream.prototype.parseBitString = function (start, end) {
        var unusedBit = this.get(start),
            lenBit = (end - start - 1 &lt;&lt; 3) - unusedBit,
            s = &quot;(&quot; + lenBit + &quot; bit)&quot;;
        if (lenBit &lt;= 20) {
            var skip = unusedBit;
            s += &quot; &quot;;
            for (var i = end - 1; i &gt; start; --i) {
                var b = this.get(i);
                for (var j = skip; j &lt; 8; ++j) {
                    s += b &gt;&gt; j &amp; 1 ? &quot;1&quot; : &quot;0&quot;;
                }
                skip = 0;
            }
        }
        return s;
    };
    Stream.prototype.parseOctetString = function (start, end) {
        var len = end - start,
            s = &quot;(&quot; + len + &quot; byte) &quot;;
        if (len &gt; hardLimit) {
            end = start + hardLimit;
        }
        for (var i = start; i &lt; end; ++i) {
            s += this.hexByte(this.get(i));
        }
        if (len &gt; hardLimit) {
            s += ellipsis;
        }
        return s;
    };
    Stream.prototype.parseOID = function (start, end) {
        var s = &quot;&quot;,
            n = 0,
            bits = 0;
        for (var i = start; i &lt; end; ++i) {
            var v = this.get(i);
            n = n &lt;&lt; 7 | v &amp; 127;
            bits += 7;
            if (!(v &amp; 128)) {
                if (s === &quot;&quot;) {
                    var m = n &lt; 80 ? n &lt; 40 ? 0 : 1 : 2;
                    s = m + &quot;.&quot; + (n - m * 40);
                } else {
                    s += &quot;.&quot; + (bits &gt;= 31 ? &quot;bigint&quot; : n);
                }
                n = bits = 0;
            }
        }
        return s;
    };
    function ASN1(stream, header, length, tag, sub) {
        this.stream = stream;
        this.header = header;
        this.length = length;
        this.tag = tag;
        this.sub = sub;
    }
    ASN1.prototype.typeName = function () {
        if (this.tag === undefined) {
            return &quot;unknown&quot;;
        }
        var tagClass = this.tag &gt;&gt; 6,
            tagConstructed = this.tag &gt;&gt; 5 &amp; 1,
            tagNumber = this.tag &amp; 31;
        switch (tagClass) {
            case 0:
                switch (tagNumber) {
                    case 0:
                        return &quot;EOC&quot;;
                    case 1:
                        return &quot;BOOLEAN&quot;;
                    case 2:
                        return &quot;INTEGER&quot;;
                    case 3:
                        return &quot;BIT_STRING&quot;;
                    case 4:
                        return &quot;OCTET_STRING&quot;;
                    case 5:
                        return &quot;NULL&quot;;
                    case 6:
                        return &quot;OBJECT_IDENTIFIER&quot;;
                    case 7:
                        return &quot;ObjectDescriptor&quot;;
                    case 8:
                        return &quot;EXTERNAL&quot;;
                    case 9:
                        return &quot;REAL&quot;;
                    case 10:
                        return &quot;ENUMERATED&quot;;
                    case 11:
                        return &quot;EMBEDDED_PDV&quot;;
                    case 12:
                        return &quot;UTF8String&quot;;
                    case 16:
                        return &quot;SEQUENCE&quot;;
                    case 17:
                        return &quot;SET&quot;;
                    case 18:
                        return &quot;NumericString&quot;;
                    case 19:
                        return &quot;PrintableString&quot;;
                    case 20:
                        return &quot;TeletexString&quot;;
                    case 21:
                        return &quot;VideotexString&quot;;
                    case 22:
                        return &quot;IA5String&quot;;
                    case 23:
                        return &quot;UTCTime&quot;;
                    case 24:
                        return &quot;GeneralizedTime&quot;;
                    case 25:
                        return &quot;GraphicString&quot;;
                    case 26:
                        return &quot;VisibleString&quot;;
                    case 27:
                        return &quot;GeneralString&quot;;
                    case 28:
                        return &quot;UniversalString&quot;;
                    case 30:
                        return &quot;BMPString&quot;;
                    default:
                        return &quot;Universal_&quot; + tagNumber.toString(16);
                }
            case 1:
                return &quot;Application_&quot; + tagNumber.toString(16);
            case 2:
                return &quot;[&quot; + tagNumber + &quot;]&quot;;
            case 3:
                return &quot;Private_&quot; + tagNumber.toString(16);
        }
    };
    ASN1.prototype.reSeemsASCII = /^[ -~]+$/;
    ASN1.prototype.content = function () {
        if (this.tag === undefined) {
            return null;
        }
        var tagClass = this.tag &gt;&gt; 6,
            tagNumber = this.tag &amp; 31,
            content = this.posContent(),
            len = Math.abs(this.length);
        if (tagClass !== 0) {
            if (this.sub !== null) {
                return &quot;(&quot; + this.sub.length + &quot; elem)&quot;;
            }
            var s = this.stream.parseStringISO(content, content + Math.min(len, hardLimit));
            if (this.reSeemsASCII.test(s)) {
                return s.substring(0, 2 * hardLimit) + (s.length &gt; 2 * hardLimit ? ellipsis : &quot;&quot;);
            } else {
                return this.stream.parseOctetString(content, content + len);
            }
        }
        switch (tagNumber) {
            case 1:
                return this.stream.get(content) === 0 ? &quot;false&quot; : &quot;true&quot;;
            case 2:
                return this.stream.parseInteger(content, content + len);
            case 3:
                return this.sub ? &quot;(&quot; + this.sub.length + &quot; elem)&quot; : this.stream.parseBitString(content, content + len);
            case 4:
                return this.sub ? &quot;(&quot; + this.sub.length + &quot; elem)&quot; : this.stream.parseOctetString(content, content + len);
            case 6:
                return this.stream.parseOID(content, content + len);
            case 16:
            case 17:
                return &quot;(&quot; + this.sub.length + &quot; elem)&quot;;
            case 12:
                return this.stream.parseStringUTF(content, content + len);
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 26:
                return this.stream.parseStringISO(content, content + len);
            case 30:
                return this.stream.parseStringBMP(content, content + len);
            case 23:
            case 24:
                return this.stream.parseTime(content, content + len);
        }
        return null;
    };
    ASN1.prototype.toString = function () {
        return this.typeName() + &quot;@&quot; + this.stream.pos + &quot;[header:&quot; + this.header + &quot;,length:&quot; + this.length + &quot;,sub:&quot; + (this.sub === null ? &quot;null&quot; : this.sub.length) + &quot;]&quot;;
    };
    ASN1.prototype.print = function (indent) {
        if (indent === undefined) {
            indent = &quot;&quot;;
        }
        document.writeln(indent + this);
        if (this.sub !== null) {
            indent += &quot;  &quot;;
            for (var i = 0, max = this.sub.length; i &lt; max; ++i) {
                this.sub[i].print(indent);
            }
        }
    };
    ASN1.prototype.toPrettyString = function (indent) {
        if (indent === undefined) {
            indent = &quot;&quot;;
        }
        var s = indent + this.typeName() + &quot; @&quot; + this.stream.pos;
        if (this.length &gt;= 0) {
            s += &quot;+&quot;;
        }
        s += this.length;
        if (this.tag &amp; 32) {
            s += &quot; (constructed)&quot;;
        } else {
            if ((this.tag == 3 || this.tag == 4) &amp;&amp; this.sub !== null) {
                s += &quot; (encapsulates)&quot;;
            }
        }
        s += &quot;\n&quot;;
        if (this.sub !== null) {
            indent += &quot;  &quot;;
            for (var i = 0, max = this.sub.length; i &lt; max; ++i) {
                s += this.sub[i].toPrettyString(indent);
            }
        }
        return s;
    };
    ASN1.prototype.toDOM = function () {
        var node = DOM.tag(&quot;div&quot;, &quot;node&quot;);
        node.asn1 = this;
        var head = DOM.tag(&quot;div&quot;, &quot;head&quot;);
        var s = this.typeName().replace(/_/g, &quot; &quot;);
        head.innerHTML = s;
        var content = this.content();
        if (content !== null) {
            content = String(content).replace(/&lt;/g, &quot;&amp;lt;&quot;);
            var preview = DOM.tag(&quot;span&quot;, &quot;preview&quot;);
            preview.appendChild(DOM.text(content));
            head.appendChild(preview);
        }
        node.appendChild(head);
        this.node = node;
        this.head = head;
        var value = DOM.tag(&quot;div&quot;, &quot;value&quot;);
        s = &quot;Offset: &quot; + this.stream.pos + &quot;&lt;br/&gt;&quot;;
        s += &quot;Length: &quot; + this.header + &quot;+&quot;;
        if (this.length &gt;= 0) {
            s += this.length;
        } else {
            s += -this.length + &quot; (undefined)&quot;;
        }
        if (this.tag &amp; 32) {
            s += &quot;&lt;br/&gt;(constructed)&quot;;
        } else {
            if ((this.tag == 3 || this.tag == 4) &amp;&amp; this.sub !== null) {
                s += &quot;&lt;br/&gt;(encapsulates)&quot;;
            }
        }
        if (content !== null) {
            s += &quot;&lt;br/&gt;Value:&lt;br/&gt;&lt;b&gt;&quot; + content + &quot;&lt;/b&gt;&quot;;
            if ((typeof oids === &quot;undefined&quot; ? &quot;undefined&quot; : _typeof(oids)) === &quot;object&quot; &amp;&amp; this.tag == 6) {
                var oid = oids[content];
                if (oid) {
                    if (oid.d) {
                        s += &quot;&lt;br/&gt;&quot; + oid.d;
                    }
                    if (oid.c) {
                        s += &quot;&lt;br/&gt;&quot; + oid.c;
                    }
                    if (oid.w) {
                        s += &quot;&lt;br/&gt;(warning!)&quot;;
                    }
                }
            }
        }
        value.innerHTML = s;
        node.appendChild(value);
        var sub = DOM.tag(&quot;div&quot;, &quot;sub&quot;);
        if (this.sub !== null) {
            for (var i = 0, max = this.sub.length; i &lt; max; ++i) {
                sub.appendChild(this.sub[i].toDOM());
            }
        }
        node.appendChild(sub);
        head.onclick = function () {
            node.className = node.className == &quot;node collapsed&quot; ? &quot;node&quot; : &quot;node collapsed&quot;;
        };
        return node;
    };
    ASN1.prototype.posStart = function () {
        return this.stream.pos;
    };
    ASN1.prototype.posContent = function () {
        return this.stream.pos + this.header;
    };
    ASN1.prototype.posEnd = function () {
        return this.stream.pos + this.header + Math.abs(this.length);
    };
    ASN1.prototype.fakeHover = function (current) {
        this.node.className += &quot; hover&quot;;
        if (current) {
            this.head.className += &quot; hover&quot;;
        }
    };
    ASN1.prototype.fakeOut = function (current) {
        var re = / ?hover/;
        this.node.className = this.node.className.replace(re, &quot;&quot;);
        if (current) {
            this.head.className = this.head.className.replace(re, &quot;&quot;);
        }
    };
    ASN1.prototype.toHexDOM_sub = function (node, className, stream, start, end) {
        if (start &gt;= end) {
            return;
        }
        var sub = DOM.tag(&quot;span&quot;, className);
        sub.appendChild(DOM.text(stream.hexDump(start, end)));
        node.appendChild(sub);
    };
    ASN1.prototype.toHexDOM = function (root) {
        var node = DOM.tag(&quot;span&quot;, &quot;hex&quot;);
        if (root === undefined) {
            root = node;
        }
        this.head.hexNode = node;
        this.head.onmouseover = function () {
            this.hexNode.className = &quot;hexCurrent&quot;;
        };
        this.head.onmouseout = function () {
            this.hexNode.className = &quot;hex&quot;;
        };
        node.asn1 = this;
        node.onmouseover = function () {
            var current = !root.selected;
            if (current) {
                root.selected = this.asn1;
                this.className = &quot;hexCurrent&quot;;
            }
            this.asn1.fakeHover(current);
        };
        node.onmouseout = function () {
            var current = root.selected == this.asn1;
            this.asn1.fakeOut(current);
            if (current) {
                root.selected = null;
                this.className = &quot;hex&quot;;
            }
        };
        this.toHexDOM_sub(node, &quot;tag&quot;, this.stream, this.posStart(), this.posStart() + 1);
        this.toHexDOM_sub(node, this.length &gt;= 0 ? &quot;dlen&quot; : &quot;ulen&quot;, this.stream, this.posStart() + 1, this.posContent());
        if (this.sub === null) {
            node.appendChild(DOM.text(this.stream.hexDump(this.posContent(), this.posEnd())));
        } else {
            if (this.sub.length &gt; 0) {
                var first = this.sub[0];
                var last = this.sub[this.sub.length - 1];
                this.toHexDOM_sub(node, &quot;intro&quot;, this.stream, this.posContent(), first.posStart());
                for (var i = 0, max = this.sub.length; i &lt; max; ++i) {
                    node.appendChild(this.sub[i].toHexDOM(root));
                }
                this.toHexDOM_sub(node, &quot;outro&quot;, this.stream, last.posEnd(), this.posEnd());
            }
        }
        return node;
    };
    ASN1.prototype.toHexString = function (root) {
        return this.stream.hexDump(this.posStart(), this.posEnd(), true);
    };
    ASN1.decodeLength = function (stream) {
        var buf = stream.get(),
            len = buf &amp; 127;
        if (len == buf) {
            return len;
        }
        if (len &gt; 3) {
            throw &quot;Length over 24 bits not supported at position &quot; + (stream.pos - 1);
        }
        if (len === 0) {
            return -1;
        }
        buf = 0;
        for (var i = 0; i &lt; len; ++i) {
            buf = buf &lt;&lt; 8 | stream.get();
        }
        return buf;
    };
    ASN1.hasContent = function (tag, len, stream) {
        if (tag &amp; 32) {
            return true;
        }
        if (tag &lt; 3 || tag &gt; 4) {
            return false;
        }
        var p = new Stream(stream);
        if (tag == 3) {
            p.get();
        }
        var subTag = p.get();
        if (subTag &gt;&gt; 6 &amp; 1) {
            return false;
        }
        try {
            var subLength = ASN1.decodeLength(p);
            return p.pos - stream.pos + subLength == len;
        } catch (exception) {
            return false;
        }
    };
    ASN1.decode = function (stream) {
        if (!(stream instanceof Stream)) {
            stream = new Stream(stream, 0);
        }
        var streamStart = new Stream(stream),
            tag = stream.get(),
            len = ASN1.decodeLength(stream),
            header = stream.pos - streamStart.pos,
            sub = null;
        if (ASN1.hasContent(tag, len, stream)) {
            var start = stream.pos;
            if (tag == 3) {
                stream.get();
            }
            sub = [];
            if (len &gt;= 0) {
                var end = start + len;
                while (stream.pos &lt; end) {
                    sub[sub.length] = ASN1.decode(stream);
                }
                if (stream.pos != end) {
                    throw &quot;Content size is not correct for container starting at offset &quot; + start;
                }
            } else {
                try {
                    for (;;) {
                        var s = ASN1.decode(stream);
                        if (s.tag === 0) {
                            break;
                        }
                        sub[sub.length] = s;
                    }
                    len = start - stream.pos;
                } catch (e) {
                    throw &quot;Exception while decoding undefined length content: &quot; + e;
                }
            }
        } else {
            stream.pos += len;
        }
        return new ASN1(streamStart, header, len, tag, sub);
    };
    ASN1.test = function () {
        var test = [{
            value: [39],
            expected: 39
        }, {
            value: [129, 201],
            expected: 201
        }, {
            value: [131, 254, 220, 186],
            expected: 16702650
        }];
        for (var i = 0, max = test.length; i &lt; max; ++i) {
            var pos = 0,
                stream = new Stream(test[i].value, 0),
                res = ASN1.decodeLength(stream);
            if (res != test[i].expected) {
                document.write(&quot;In test[&quot; + i + &quot;] expected &quot; + test[i].expected + &quot; got &quot; + res + &quot;\n&quot;);
            }
        }
    };
    window.ASN1 = ASN1;
})();
ASN1.prototype.getHexStringValue = function () {
    var hexString = this.toHexString();
    var offset = this.header * 2;
    var length = this.length * 2;
    return hexString.substr(offset, length);
};
RSAKey.prototype.parseKey = function (pem) {
    try {
        var reHex = /^\s*(?:[0-9A-Fa-f][0-9A-Fa-f]\s*)+$/;
        var der = reHex.test(pem) ? Hex.decode(pem) : Base64.unarmor(pem);
        var asn1 = ASN1.decode(der);
        if (asn1.sub.length === 9) {
            var modulus = asn1.sub[1].getHexStringValue();
            this.n = parseBigInt(modulus, 16);
            var public_exponent = asn1.sub[2].getHexStringValue();
            this.e = parseInt(public_exponent, 16);
            var private_exponent = asn1.sub[3].getHexStringValue();
            this.d = parseBigInt(private_exponent, 16);
            var prime1 = asn1.sub[4].getHexStringValue();
            this.p = parseBigInt(prime1, 16);
            var prime2 = asn1.sub[5].getHexStringValue();
            this.q = parseBigInt(prime2, 16);
            var exponent1 = asn1.sub[6].getHexStringValue();
            this.dmp1 = parseBigInt(exponent1, 16);
            var exponent2 = asn1.sub[7].getHexStringValue();
            this.dmq1 = parseBigInt(exponent2, 16);
            var coefficient = asn1.sub[8].getHexStringValue();
            this.coeff = parseBigInt(coefficient, 16);
        } else {
            if (asn1.sub.length === 2) {
                var bit_string = asn1.sub[1];
                var sequence = bit_string.sub[0];
                var modulus = sequence.sub[0].getHexStringValue();
                this.n = parseBigInt(modulus, 16);
                var public_exponent = sequence.sub[1].getHexStringValue();
                this.e = parseInt(public_exponent, 16);
            } else {
                return false;
            }
        }
        return true;
    } catch (ex) {
        return false;
    }
};
RSAKey.prototype.getPrivateBaseKey = function () {
    var options = {
        array: [new KJUR.asn1.DERInteger({
            &quot;int&quot;: 0
        }), new KJUR.asn1.DERInteger({
            bigint: this.n
        }), new KJUR.asn1.DERInteger({
            &quot;int&quot;: this.e
        }), new KJUR.asn1.DERInteger({
            bigint: this.d
        }), new KJUR.asn1.DERInteger({
            bigint: this.p
        }), new KJUR.asn1.DERInteger({
            bigint: this.q
        }), new KJUR.asn1.DERInteger({
            bigint: this.dmp1
        }), new KJUR.asn1.DERInteger({
            bigint: this.dmq1
        }), new KJUR.asn1.DERInteger({
            bigint: this.coeff
        })]
    };
    var seq = new KJUR.asn1.DERSequence(options);
    return seq.getEncodedHex();
};
RSAKey.prototype.getPrivateBaseKeyB64 = function () {
    return hex2b64(this.getPrivateBaseKey());
};
RSAKey.prototype.getPublicBaseKey = function () {
    var options = {
        array: [new KJUR.asn1.DERObjectIdentifier({
            oid: &quot;1.2.840.113549.1.1.1&quot;
        }), new KJUR.asn1.DERNull()]
    };
    var first_sequence = new KJUR.asn1.DERSequence(options);
    options = {
        array: [new KJUR.asn1.DERInteger({
            bigint: this.n
        }), new KJUR.asn1.DERInteger({
            &quot;int&quot;: this.e
        })]
    };
    var second_sequence = new KJUR.asn1.DERSequence(options);
    options = {
        hex: &quot;00&quot; + second_sequence.getEncodedHex()
    };
    var bit_string = new KJUR.asn1.DERBitString(options);
    options = {
        array: [first_sequence, bit_string]
    };
    var seq = new KJUR.asn1.DERSequence(options);
    return seq.getEncodedHex();
};
RSAKey.prototype.getPublicBaseKeyB64 = function () {
    return hex2b64(this.getPublicBaseKey());
};
RSAKey.prototype.wordwrap = function (str, width) {
    width = width || 64;
    if (!str) {
        return str;
    }
    var regex = &quot;(.{1,&quot; + width + &quot;})( +|$\n?)|(.{1,&quot; + width + &quot;})&quot;;
    return str.match(RegExp(regex, &quot;g&quot;)).join(&quot;\n&quot;);
};
RSAKey.prototype.getPrivateKey = function () {
    var key = &quot;-----BEGIN RSA PRIVATE KEY-----\n&quot;;
    key += this.wordwrap(this.getPrivateBaseKeyB64()) + &quot;\n&quot;;
    key += &quot;-----END RSA PRIVATE KEY-----&quot;;
    return key;
};
RSAKey.prototype.getPublicKey = function () {
    var key = &quot;-----BEGIN PUBLIC KEY-----\n&quot;;
    key += this.wordwrap(this.getPublicBaseKeyB64()) + &quot;\n&quot;;
    key += &quot;-----END PUBLIC KEY-----&quot;;
    return key;
};
RSAKey.prototype.hasPublicKeyProperty = function (obj) {
    obj = obj || {};
    return obj.hasOwnProperty(&quot;n&quot;) &amp;&amp; obj.hasOwnProperty(&quot;e&quot;);
};
RSAKey.prototype.hasPrivateKeyProperty = function (obj) {
    obj = obj || {};
    return obj.hasOwnProperty(&quot;n&quot;) &amp;&amp; obj.hasOwnProperty(&quot;e&quot;) &amp;&amp; obj.hasOwnProperty(&quot;d&quot;) &amp;&amp; obj.hasOwnProperty(&quot;p&quot;) &amp;&amp; obj.hasOwnProperty(&quot;q&quot;) &amp;&amp; obj.hasOwnProperty(&quot;dmp1&quot;) &amp;&amp; obj.hasOwnProperty(&quot;dmq1&quot;) &amp;&amp; obj.hasOwnProperty(&quot;coeff&quot;);
};
RSAKey.prototype.parsePropertiesFrom = function (obj) {
    this.n = obj.n;
    this.e = obj.e;
    if (obj.hasOwnProperty(&quot;d&quot;)) {
        this.d = obj.d;
        this.p = obj.p;
        this.q = obj.q;
        this.dmp1 = obj.dmp1;
        this.dmq1 = obj.dmq1;
        this.coeff = obj.coeff;
    }
};
var JSEncryptRSAKey = function JSEncryptRSAKey(key) {
    RSAKey.call(this);
    if (key) {
        if (typeof key === &quot;string&quot;) {
            this.parseKey(key);
        } else {
            if (this.hasPrivateKeyProperty(key) || this.hasPublicKeyProperty(key)) {
                this.parsePropertiesFrom(key);
            }
        }
    }
};
JSEncryptRSAKey.prototype = new RSAKey();
JSEncryptRSAKey.prototype.constructor = JSEncryptRSAKey;
var JSEncrypt = function JSEncrypt(options) {
    options = options || {};
    this.default_key_size = parseInt(options.default_key_size) || 1024;
    this.default_public_exponent = options.default_public_exponent || &quot;010001&quot;;
    this.log = options.log || false;
    this.key = null;
};
JSEncrypt.prototype.setKey = function (key) {
    if (this.log &amp;&amp; this.key) {
        console.warn(&quot;A key was already set, overriding existing.&quot;);
    }
    this.key = new JSEncryptRSAKey(key);
};
JSEncrypt.prototype.setPrivateKey = function (privkey) {
    this.setKey(privkey);
};
JSEncrypt.prototype.setPublicKey = function (pubkey) {
    this.setKey(pubkey);
};
JSEncrypt.prototype.decrypt = function (string) {
    try {
        return this.getKey().decrypt(b64tohex(string));
    } catch (ex) {
        return false;
    }
};
JSEncrypt.prototype.encrypt = function (string) {
    try {
        return hex2b64(this.getKey().encrypt(string));
    } catch (ex) {
        return false;
    }
};
JSEncrypt.prototype.getKey = function (cb) {
    if (!this.key) {
        this.key = new JSEncryptRSAKey();
        if (cb &amp;&amp; {}.toString.call(cb) === &quot;[object Function]&quot;) {
            this.key.generateAsync(this.default_key_size, this.default_public_exponent, cb);
            return;
        }
        this.key.generate(this.default_key_size, this.default_public_exponent);
    }
    return this.key;
};
JSEncrypt.prototype.getPrivateKey = function () {
    return this.getKey().getPrivateKey();
};
JSEncrypt.prototype.getPrivateKeyB64 = function () {
    return this.getKey().getPrivateBaseKeyB64();
};
JSEncrypt.prototype.getPublicKey = function () {
    return this.getKey().getPublicKey();
};
JSEncrypt.prototype.getPublicKeyB64 = function () {
    return this.getKey().getPublicBaseKeyB64();
};

exports.RSA = JSEncrypt;

/***/ }),

/***/ &quot;MzSj&quot;:
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c(&#39;section&#39;, {
    staticClass: &quot;s_2&quot;
  }, [_c(&#39;div&#39;, {
    staticClass: &quot;input_wrap&quot;
  }, [_vm._m(0), _vm._v(&quot; &quot;), _c(&#39;input&#39;, {
    directives: [{
      name: &quot;model&quot;,
      rawName: &quot;v-model.trim&quot;,
      value: (_vm.nickname),
      expression: &quot;nickname&quot;,
      modifiers: {
        &quot;trim&quot;: true
      }
    }],
    attrs: {
      &quot;type&quot;: &quot;text&quot;,
      &quot;name&quot;: &quot;nickname&quot;,
      &quot;id&quot;: &quot;nickname&quot;,
      &quot;placeholder&quot;: &quot;请输入2-10个字昵称&quot;
    },
    domProps: {
      &quot;value&quot;: (_vm.nickname)
    },
    on: {
      &quot;input&quot;: function($event) {
        if ($event.target.composing) { return; }
        _vm.nickname = $event.target.value.trim()
      },
      &quot;blur&quot;: function($event) {
        _vm.$forceUpdate()
      }
    }
  })]), _vm._v(&quot; &quot;), _c(&#39;div&#39;, {
    staticClass: &quot;input_wrap&quot;
  }, [_vm._m(1), _vm._v(&quot; &quot;), _c(&#39;input&#39;, {
    directives: [{
      name: &quot;model&quot;,
      rawName: &quot;v-model.trim&quot;,
      value: (_vm.password),
      expression: &quot;password&quot;,
      modifiers: {
        &quot;trim&quot;: true
      }
    }],
    attrs: {
      &quot;type&quot;: &quot;password&quot;,
      &quot;name&quot;: &quot;password&quot;,
      &quot;id&quot;: &quot;password&quot;,
      &quot;placeholder&quot;: &quot;请输入6-16位密码&quot;
    },
    domProps: {
      &quot;value&quot;: (_vm.password)
    },
    on: {
      &quot;input&quot;: function($event) {
        if ($event.target.composing) { return; }
        _vm.password = $event.target.value.trim()
      },
      &quot;blur&quot;: function($event) {
        _vm.$forceUpdate()
      }
    }
  })]), _vm._v(&quot; &quot;), _c(&#39;div&#39;, {
    staticClass: &quot;input_wrap&quot;
  }, [_vm._m(2), _vm._v(&quot; &quot;), _c(&#39;input&#39;, {
    staticClass: &quot;sex&quot;,
    attrs: {
      &quot;type&quot;: &quot;radio&quot;,
      &quot;name&quot;: &quot;sex&quot;,
      &quot;value&quot;: &quot;1&quot;
    },
    on: {
      &quot;click&quot;: _vm.showSexHint
    }
  }), _vm._v(&quot;男\n\t\t&quot;), _c(&#39;input&#39;, {
    staticClass: &quot;sex&quot;,
    attrs: {
      &quot;type&quot;: &quot;radio&quot;,
      &quot;name&quot;: &quot;sex&quot;,
      &quot;value&quot;: &quot;2&quot;
    },
    on: {
      &quot;click&quot;: _vm.showSexHint
    }
  }), _vm._v(&quot;女\n\t\t&quot;), _c(&#39;P&#39;, {
    staticClass: &quot;err_hint&quot;
  })], 1), _vm._v(&quot; &quot;), _c(&#39;button&#39;, {
    staticClass: &quot;sp_next_btn btn&quot;,
    on: {
      &quot;click&quot;: function($event) {
        _vm.verifyInfo()
      }
    }
  }, [_vm._v(&quot;\n\t\t完成\n\t&quot;)])])
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c(&#39;label&#39;, {
    attrs: {
      &quot;for&quot;: &quot;nickname&quot;
    }
  }, [_c(&#39;i&#39;, {
    staticClass: &quot;nickname_icon&quot;
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c(&#39;label&#39;, {
    attrs: {
      &quot;for&quot;: &quot;password&quot;
    }
  }, [_c(&#39;i&#39;, {
    staticClass: &quot;password_icon&quot;
  })])
},function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c(&#39;label&#39;, {
    attrs: {
      &quot;for&quot;: &quot;sex&quot;
    }
  }, [_c(&#39;i&#39;, {
    staticClass: &quot;sex_icon&quot;
  })])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require(&quot;vue-hot-reload-api&quot;).rerender(&quot;data-v-adc40464&quot;, module.exports)
  }
}

/***/ }),

/***/ &quot;PVZc&quot;:
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(&quot;VU/8&quot;)(
  /* script */
  __webpack_require__(&quot;2wU1&quot;),
  /* template */
  __webpack_require__(&quot;MzSj&quot;),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = &quot;F:\\source\\static_guojiang_tv\\src\\mobile\\v2\\js\\joinOrg\\setProfile.vue&quot;
if (Component.esModule &amp;&amp; Object.keys(Component.esModule).some(function (key) {return key !== &quot;default&quot; &amp;&amp; key !== &quot;__esModule&quot;})) {console.error(&quot;named exports are not supported in *.vue files.&quot;)}
if (Component.options.functional) {console.error(&quot;[vue-loader] setProfile.vue: functional components are not supported with templates, they should use render functions.&quot;)}

/* hot reload */
if (false) {(function () {
  var hotAPI = require(&quot;vue-hot-reload-api&quot;)
  hotAPI.install(require(&quot;vue&quot;), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord(&quot;data-v-adc40464&quot;, Component.options)
  } else {
    hotAPI.reload(&quot;data-v-adc40464&quot;, Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),

/***/ &quot;QnnF&quot;:
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _vm._m(0)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c(&#39;section&#39;, {
    staticClass: &quot;s_3&quot;
  }, [_c(&#39;span&#39;, {
    staticClass: &quot;icon&quot;
  }), _vm._v(&quot; &quot;), _c(&#39;p&#39;, {
    staticClass: &quot;icon_hint&quot;
  }, [_vm._v(&quot;加入成功&quot;)]), _vm._v(&quot; &quot;), _c(&#39;p&#39;, {
    staticClass: &quot;result_hint&quot;
  }, [_vm._v(&quot;快去下载APP开播，赚取收益吧&quot;)]), _vm._v(&quot; &quot;), _c(&#39;a&#39;, {
    staticClass: &quot;btn&quot;,
    attrs: {
      &quot;href&quot;: &quot;/download/tuhao&quot;
    }
  }, [_vm._v(&quot;去下载&quot;)])])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require(&quot;vue-hot-reload-api&quot;).rerender(&quot;data-v-4556c021&quot;, module.exports)
  }
}

/***/ }),

/***/ &quot;STya&quot;:
/***/ (function(module, exports, __webpack_require__) {

var Component = __webpack_require__(&quot;VU/8&quot;)(
  /* script */
  null,
  /* template */
  __webpack_require__(&quot;QnnF&quot;),
  /* scopeId */
  null,
  /* cssModules */
  null
)
Component.options.__file = &quot;F:\\source\\static_guojiang_tv\\src\\mobile\\v2\\js\\joinOrg\\bindResult.vue&quot;
if (Component.esModule &amp;&amp; Object.keys(Component.esModule).some(function (key) {return key !== &quot;default&quot; &amp;&amp; key !== &quot;__esModule&quot;})) {console.error(&quot;named exports are not supported in *.vue files.&quot;)}
if (Component.options.functional) {console.error(&quot;[vue-loader] bindResult.vue: functional components are not supported with templates, they should use render functions.&quot;)}

/* hot reload */
if (false) {(function () {
  var hotAPI = require(&quot;vue-hot-reload-api&quot;)
  hotAPI.install(require(&quot;vue&quot;), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord(&quot;data-v-4556c021&quot;, Component.options)
  } else {
    hotAPI.reload(&quot;data-v-4556c021&quot;, Component.options)
  }
})()}

module.exports = Component.exports


/***/ }),

/***/ &quot;VU/8&quot;:
/***/ (function(module, exports) {

// this module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  scopeId,
  cssModules
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === &#39;object&#39; || type === &#39;function&#39;) {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === &#39;function&#39;
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  // inject cssModules
  if (cssModules) {
    var computed = Object.create(options.computed || null)
    Object.keys(cssModules).forEach(function (key) {
      var module = cssModules[key]
      computed[key] = function () { return module }
    })
    options.computed = computed
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ &quot;WnVb&quot;:
/***/ (function(module, exports, __webpack_require__) {

module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c(&#39;section&#39;, {
    staticClass: &quot;s_1&quot;
  }, [_c(&#39;h2&#39;, [_vm._v(&quot;─────── ─ 您所加入的工会为 ─ ───────&quot;)]), _vm._v(&quot; &quot;), _c(&#39;h3&#39;, [_vm._v(_vm._s(_vm.orgName))]), _vm._v(&quot; &quot;), _c(&#39;P&#39;, {
    staticClass: &quot;org_id&quot;
  }, [_vm._v(&quot;工会ID：&quot; + _vm._s(_vm.orgId))]), _vm._v(&quot; &quot;), _c(&#39;div&#39;, {
    staticClass: &quot;input_wrap&quot;
  }, [_c(&#39;label&#39;, {
    attrs: {
      &quot;for&quot;: &quot;tel&quot;
    }
  }, [_vm._v(&quot;+86&quot;)]), _vm._v(&quot; &quot;), _c(&#39;input&#39;, {
    directives: [{
      name: &quot;model&quot;,
      rawName: &quot;v-model.trim&quot;,
      value: (_vm.tel),
      expression: &quot;tel&quot;,
      modifiers: {
        &quot;trim&quot;: true
      }
    }],
    attrs: {
      &quot;type&quot;: &quot;tel&quot;,
      &quot;name&quot;: &quot;tel&quot;,
      &quot;id&quot;: &quot;tel&quot;,
      &quot;placeholder&quot;: &quot;请输入手机号&quot;
    },
    domProps: {
      &quot;value&quot;: (_vm.tel)
    },
    on: {
      &quot;input&quot;: [function($event) {
        if ($event.target.composing) { return; }
        _vm.tel = $event.target.value.trim()
      }, function($event) {
        _vm.restrictTel($event.target.value)
      }],
      &quot;blur&quot;: [function($event) {
        _vm.verifyTel($event.target.value)
      }, function($event) {
        _vm.$forceUpdate()
      }]
    }
  })]), _vm._v(&quot; &quot;), _c(&#39;div&#39;, {
    staticClass: &quot;input_wrap&quot;
  }, [_c(&#39;input&#39;, {
    directives: [{
      name: &quot;model&quot;,
      rawName: &quot;v-model.trim&quot;,
      value: (_vm.authCode),
      expression: &quot;authCode&quot;,
      modifiers: {
        &quot;trim&quot;: true
      }
    }],
    attrs: {
      &quot;type&quot;: &quot;text&quot;,
      &quot;name&quot;: &quot;authCode&quot;,
      &quot;id&quot;: &quot;authCode&quot;,
      &quot;placeholder&quot;: &quot;请输入短信验证码&quot;
    },
    domProps: {
      &quot;value&quot;: (_vm.authCode)
    },
    on: {
      &quot;input&quot;: [function($event) {
        if ($event.target.composing) { return; }
        _vm.authCode = $event.target.value.trim()
      }, function($event) {
        _vm.restrictAuthCode($event.target.value)
      }],
      &quot;blur&quot;: function($event) {
        _vm.$forceUpdate()
      }
    }
  }), _vm._v(&quot; &quot;), _c(&#39;label&#39;, {
    directives: [{
      name: &quot;show&quot;,
      rawName: &quot;v-show&quot;,
      value: (!_vm.getingVcode),
      expression: &quot;!getingVcode&quot;
    }],
    on: {
      &quot;click&quot;: function($event) {
        _vm.getAuthCode($event)
      }
    }
  }, [_vm._v(&quot;发送&quot;)]), _vm._v(&quot; &quot;), _c(&#39;label&#39;, {
    directives: [{
      name: &quot;show&quot;,
      rawName: &quot;v-show&quot;,
      value: (_vm.getingVcode),
      expression: &quot;getingVcode&quot;
    }],
    staticClass: &quot;geting_vcode&quot;
  }, [_vm._v(&quot;重新发送(&quot; + _vm._s(_vm.countDownNum) + &quot;)&quot;)]), _vm._v(&quot; &quot;), _c(&#39;P&#39;, {
    staticClass: &quot;err_hint&quot;
  }, [_vm._v(_vm._s(_vm.errMsg))]), _vm._v(&quot; &quot;), _vm._m(0)], 1), _vm._v(&quot; &quot;), _c(&#39;button&#39;, {
    staticClass: &quot;ac_next_btn btn&quot;,
    on: {
      &quot;click&quot;: _vm.verifyAuthCode
    }
  }, [_vm._v(&quot;\n\t\t下一步\n\t&quot;)]), _vm._v(&quot; &quot;), _c(&#39;P&#39;, {
    staticClass: &quot;deal_hint&quot;
  }, [_vm._v(&quot;注册即表示同意&quot;), _c(&#39;a&#39;, {
    attrs: {
      &quot;href&quot;: &quot;javascript:;&quot;
    }
  }, [_vm._v(&quot;用户协议&quot;)])])], 1)
},staticRenderFns: [function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;
  return _c(&#39;div&#39;, {
    staticClass: &quot;hide&quot;,
    attrs: {
      &quot;id&quot;: &quot;geePhoneCaptchaWrap&quot;
    }
  }, [_c(&#39;span&#39;, {
    staticClass: &quot;wait_gee_captcha&quot;
  }, [_vm._v(&quot;正在获取滑动验证码&quot;)]), _vm._v(&quot; &quot;), _c(&#39;div&#39;, {
    attrs: {
      &quot;id&quot;: &quot;geePhoneCaptcha&quot;
    }
  })])
}]}
module.exports.render._withStripped = true
if (false) {
  module.hot.accept()
  if (module.hot.data) {
     require(&quot;vue-hot-reload-api&quot;).rerender(&quot;data-v-9be47758&quot;, module.exports)
  }
}

/***/ }),

/***/ &quot;WrUb&quot;:
/***/ (function(module, exports, __webpack_require__) {

&quot;use strict&quot;;


Object.defineProperty(exports, &quot;__esModule&quot;, {
    value: true
});

var _common = __webpack_require__(&quot;iKyZ&quot;);

var _common2 = _interopRequireDefault(_common);

var _webpackZepto = __webpack_require__(4);

var _webpackZepto2 = _interopRequireDefault(_webpackZepto);

var _axios = __webpack_require__(1);

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj &amp;&amp; obj.__esModule ? obj : { default: obj }; }

var _data = {
    tel: &#39;&#39;,
    authCode: &#39;&#39;,
    errMsg: &#39;&#39;,
    orgId: &#39;&#39;,
    orgName: &#39;&#39;,
    countDownNum: 60,
    getingVcode: false,
    nextClickFlag: true,
    geeFlag: false, //防止连续点击生成多个极验验证码
    hasGee: false,
    captchaObj: null //极验对象
}; //
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

exports.default = {
    data: function data() {
        return _data;
    },
    props: [&#39;info&#39;],
    mounted: function mounted() {
        this.initOrgInfo();
    },
    methods: {
        initOrgInfo: function initOrgInfo() {
            var _this = this;

            var manager = location.search.split(&#39;manager=&#39;)[1].split(&#39;&amp;&#39;)[0];

            _axios2.default.get(&#39;/joinOrg/initOrg&#39;, {
                params: {
                    manager: manager
                }
            }).then(function (res) {
                res = res.data;
                if (res.errno == 0) {
                    _this.orgId = res.data.orgInfo.id;
                    _this.orgName = res.data.orgInfo.name;
                } else {
                    layer.open({
                        content: res.msg,
                        skin: &#39;msg&#39;,
                        tip: 3
                    });
                }
            }, function (err) {
                alert(err);
            });
        },
        restrictTel: function restrictTel(val) {
            this.verifyTel(val);
            this.tel = val.match(/^[1]\d*/g) ? val.match(/^[1]\d*/g)[0] : &#39;&#39;;

            this.info.tel = this.tel;
        },
        restrictAuthCode: function restrictAuthCode(val) {
            this.authCode = val.match(/\d+/g) ? val.match(/\d+/g)[0] : &#39;&#39;;
            this.info.authCode = this.authCode;
        },
        verifyTel: function verifyTel(val) {
            var regExp = _common2.default.regExpTest(val, &#39;mobile&#39;);

            if (!regExp.errno) {
                this.errMsg = regExp.msg;
            } else {
                this.errMsg = &#39;&#39;;
            }
        },
        getAuthCode: function getAuthCode(obj) {

            if (this.tel == &#39;&#39;) {
                layer.open({
                    content: &#39;请先填写手机号&#39;,
                    skin: &#39;msg&#39;,
                    time: 3
                });
                (0, _webpackZepto2.default)(&#39;#tel&#39;).focus();
                return;
            }

            //手机格式错误
            if (this.errMsg != &#39;&#39;) return;

            //拉取极验验证码
            if (!this.hasGee &amp;&amp; !this.geeFlag) {

                this.geeFlag = true;
                this.initGeeCaptcha();
            } else if (this.hasGee) {

                //验证是否已拖动滑块到正确位置
                var validate = this.captchaObj.getValidate();
                if (!validate) {
                    layer.open({
                        content: &#39;请先拖动验证码到相应位置&#39;,
                        skin: &#39;msg&#39;,
                        time: 3
                    });
                    return;
                } else {
                    //发送验证码
                    this.sendAuthCode();
                }
            }
        },
        initGeeCaptcha: function initGeeCaptcha() {
            var vm = this;
            (0, _webpackZepto2.default)(&#39;#geePhoneCaptcha&#39;).html(&#39;&#39;);

            _axios2.default.get(&#39;/user/StartCaptchaServlet?t=&#39; + new Date().getTime()).then(function (res) {
                _data = res.data;
                // 使用initGeetest接口
                // 参数1：配置参数
                // 参数2：回调，回调的第一个参数验证码对象，之后可以使用它做appendTo之类的事件
                initGeetest({
                    gt: _data.gt,
                    challenge: _data.challenge,
                    product: &quot;embed&quot;, // 产品形式，包括：float，embed，popup。注意只对PC版验证码有效
                    offline: !_data.success // 表示用户后台检测极验服务器是否宕机，一般不需要关注
                }, function (captchaObj) {
                    vm.handlerEmbed(captchaObj);
                });

                (0, _webpackZepto2.default)(&#39;#geePhoneCaptchaWrap&#39;).show();
                vm.geeFlag = false;
                vm.hasGee = true;
            }, function (err) {
                console.log(err);
                vm.geeFlag = false;
                vm.hasGee = true;
            });
        },
        handlerEmbed: function handlerEmbed(captchaObj) {
            var vm = this;

            // 将验证码加到id为captcha的元素里
            captchaObj.appendTo(&quot;#geePhoneCaptcha&quot;);
            captchaObj.onReady(function () {
                (0, _webpackZepto2.default)(&quot;.wait_gee_captcha&quot;).hide();
            });
            captchaObj.onSuccess(function () {
                (0, _webpackZepto2.default)(&#39;#geePhoneCaptchaWrap&#39;).hide();
                //发送验证码
                vm.sendAuthCode();
            });

            vm.captchaObj = captchaObj;
        },
        sendAuthCode: function sendAuthCode() {
            var _this2 = this;

            _common2.default.showLoading();

            var validate = this.captchaObj.getValidate();
            _axios2.default.get(&#39;/user/getMobileVCode&#39;, {
                params: {
                    mobile: this.tel,
                    geetest_challenge: validate.geetest_challenge,
                    geetest_validate: validate.geetest_validate,
                    geetest_seccode: validate.geetest_seccode
                }
            }).then(function (res) {
                _common2.default.hideLoading();

                res = res.data;
                if (res.errno == 0) {

                    _this2.getingVcode = true;
                    //开始倒计时
                    _this2.startCountDown();
                } else {

                    layer.open({
                        content: res.msg,
                        skin: &#39;msg&#39;,
                        time: 3
                    }

                    //验证失败重新初始化验证码
                    );if (res.errno == 1105) {
                        _this2.hasGee = false;
                    }
                }
            }, function (err) {
                console.log(err);
            });
        },
        startCountDown: function startCountDown() {
            var vm = this;
            var count_down = setInterval(function () {
                if (vm.countDownNum &gt; 1) {
                    vm.countDownNum--;
                } else {
                    clearInterval(count_down);
                    vm.getingVcode = false;
                    vm.countDownNum = 60;
                }
            }, 1000);
        },
        verifyAuthCode: function verifyAuthCode() {
            var _this3 = this;

            if (!this.nextClickFlag) return;

            if (!this.tel || this.tel == &#39;&#39;) {
                layer.open({
                    content: &#39;请先正确填写手机号&#39;,
                    skin: &#39;msg&#39;,
                    time: 3
                });
                return;
            }
            if (!this.authCode || this.authCode == &#39;&#39;) {
                layer.open({
                    content: &#39;请先获取验证码&#39;,
                    skin: &#39;msg&#39;,
                    time: 3
                });
                return;
            }
            this.nextClickFlag = false;

            _common2.default.showLoading();

            _axios2.default.get(&#39;/user/isVcodeCurrect&#39;, {
                params: {
                    mobile: this.tel,
                    vcode: this.authCode
                }
            }).then(function (res) {
                _this3.nextClickFlag = true;
                _common2.default.hideLoading();
                res = res.data;

                if (res.errno == 0) {
                    //step to next page
                    _this3.nextStep();
                } else {
                    layer.open({
                        content: res.msg,
                        skin: &#39;msg&#39;,
                        time: 3
                    }
                    //验证失败重新初始化验证码
                    );_this3.hasGee = false;
                }
            }, function (err) {
                _this3.nextClickFlag = true;
                console.log(err);
            });
        },
        nextStep: function nextStep() {
            router.push(&#39;/setProfile&#39;);
        }
    }
};

/***/ }),

/***/ &quot;kMPS&quot;:
/***/ (function(module, exports, __webpack_require__) {

&quot;use strict&quot;;
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// &quot;Software&quot;), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || &#39;&amp;&#39;;
  eq = eq || &#39;=&#39;;
  var obj = {};

  if (typeof qs !== &#39;string&#39; || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options &amp;&amp; typeof options.maxKeys === &#39;number&#39;) {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys &lt;= 0 means that we should not limit keys count
  if (maxKeys &gt; 0 &amp;&amp; len &gt; maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i &lt; len; ++i) {
    var x = qs[i].replace(regexp, &#39;%20&#39;),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx &gt;= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = &#39;&#39;;
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === &#39;[object Array]&#39;;
};

/***/ }),

/***/ &quot;xaZU&quot;:
/***/ (function(module, exports, __webpack_require__) {

&quot;use strict&quot;;
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// &quot;Software&quot;), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var _typeof = typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot; ? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj; };

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (typeof v === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(v)) {
    case &#39;string&#39;:
      return v;

    case &#39;boolean&#39;:
      return v ? &#39;true&#39; : &#39;false&#39;;

    case &#39;number&#39;:
      return isFinite(v) ? v : &#39;&#39;;

    default:
      return &#39;&#39;;
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || &#39;&amp;&#39;;
  eq = eq || &#39;=&#39;;
  if (obj === null) {
    obj = undefined;
  }

  if ((typeof obj === &#39;undefined&#39; ? &#39;undefined&#39; : _typeof(obj)) === &#39;object&#39;) {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return &#39;&#39;;
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === &#39;[object Array]&#39;;
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i &lt; xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

/***/ })

},[&quot;8K/C&quot;]);
//# sourceMappingURL=index.js.map?v=1d486acd
</code></pre>
<h2 id="meadowlark-js">meadowlark.js</h2>
<pre><code class="lang-js">var express = require(&quot;express&quot;)
var app = express()
var handlebars = require(&quot;express-handlebars&quot;).create({defaultLayout:&quot;main&quot;})

var fortunes = [
    &quot;Conquer your fears or they will conquer you&quot;,
    &quot;Rivers need springs&quot;,
    &quot;Do not fear what you dont know&quot;,
    &quot;You will have a pleasant surprise&quot;,
    &quot;Whenever possible,keep it simplesss&quot;
]
app.disable(&quot;x-powered-by&quot;)
app.engine(&quot;handlebars&quot;,handlebars.engine)
app.set(&quot;view engine&quot;,&quot;handlebars&quot;)

app.set(&quot;port&quot;,process.env.PORT || 3000)

app.use(express.static(__dirname+&quot;/public&quot;))

// 使用中间件
app.use(require(&quot;body-parser&quot;)())
app.get(&quot;/&quot;,(req,res)=&gt;{
    res.render(&quot;home&quot;)
})

app.get(&quot;/headers&quot;,(req,res)=&gt;{
    res.set(&quot;Content-Type&quot;,&quot;text/plain&quot;)
    var s = &quot;&quot;
    for(var name in req.headers){
        s += name + &quot;:&quot; + req.headers[name] + &quot;\n&quot;
    }
    res.send(s)
})

app.get(&quot;/about&quot;,(req,res)=&gt;{
    var randomFortune = fortunes[Math.floor(Math.random()*fortunes.length)]
    res.render(&quot;about&quot;,{fortune:randomFortune})
})




// basic form dealt
app.post(&quot;/process-contact&quot;,(req,res)=&gt;{
    console.log(&quot;Received contact from &quot;+ req.body.name + &quot;&lt;&quot;+
        req.body.email + &quot;&gt;&quot;)
        res.redirect(303,&quot;/thank-you&quot;)
})

// complex form dealt
app.post(&quot;/process-contact&quot;,(req,res)=&gt;{
    try{
        // store in database
        return res.xhr?res.render({success:true})
                      :res.redirect(303,&quot;/thank-you&quot;)
    }catch(ex){
        return rex.xhr?res.json({error:&quot;Database error&quot;})
                      :res.redirect(303,&quot;/database-error&quot;)
    }
})

// provide an api
var tours = [
    {id:0,name:&quot;Hood River&quot;,price:99.99},
    {id:1,name:&quot;Oregon Coast&quot;,price:149.95}
]
// node which is quite often used to describle sole api method
app.put(&#39;/api/tour/:id&#39;,(req,res)=&gt;{
    var p = tours.some((p)=&gt;{
        return p.id == req.params.id
    })

    if(p){
        if(req.query.name){
            p.name = req.query.name
        }
        if(req.query.price){
            p.price = req.query.price
        }
    }else{
        res.json({error:&quot;No such tour exists.&quot;})
    }
})

// delet an product
app.delete(&#39;/api/tour/:id&#39;,(req,res)=&gt;{
    var i 
    for(var i = tours.lengh - 1;i &gt;= 0 ;i-- ){
        if(tours[i].id == req.params.id) break
        if(i &gt;=0){
            tours.splice(i,1)
            res.json({success:true})
        }else{
            res.json({error:&quot;No such tour exists.&quot;})
        }
    }
})


// 404
app.use((req,res)=&gt;{
    res.type(&quot;text/plain&quot;)
    res.status(404)
    res.render(&quot;404&quot;)
})
// 500
app.use((err,req,res,next)=&gt;{
    console.log(err.stack)
    res.type(&quot;text/plain&quot;)
    res.status(500)
    res.render(&quot;500&quot;)
})

app.listen(app.get(&quot;port&quot;),()=&gt;{
    console.log(&quot;Express started on http://localhost&quot; + app.get(&quot;port&quot;) + &quot;;press Ctrl-C to terminate.&quot;)
})
</code></pre>
<h2 id="net-js">net.js</h2>
<pre><code class="lang-js">/**
 * The net module provides you with an asynchronous network wrapper.It contains functions for creating both servers and clients(called streams).You can include this module with require(&quot;net&quot;)
 */ 

/**
 * Class net.server 
 * This class is used to create a TCP or local server
 * net.server is an event.Emitter with the following events
 * close + connection + error + listening 
 */

/**
 * server.address()
 * Return the bound address ,the address family name ,and port of the server as reported by the operating system.Useful to find which port was assigned when getting an OS-assigned address.
 * Return an object with port,family,and address properties:{port:12346,family:&quot;IPv4&quot;,address:&quot;127.0.0.1&quot;}
 * 
 */

// const net = require(&quot;net&quot;)
// const server = net.createServer((socket)=&gt;{
//     socket.end(&quot;goodbye\n&quot;)
// }).on(&quot;error&quot;,(error)=&gt;{
//     throw err
// })

// server.listen(()=&gt;{
//     console.log(&quot;opened server on&quot;,server.address())
// })
// 
/**
 * server.cloes(callback)
 * Stops the server from accepting new connections and keeps existing connections.This function is asychronous,the server is finally closed when all connections are ended and the server emits
 * a &quot;close&quot; event occurs.Unlike that event,it will be called with an Error as its only argument if the server was not open when it was closed
 *
 * server.getConnections(callback)
 * Asychronously get the number of concurrent connections on the server.Works when sockets were sent to forks.Callback should take two arguments err and count
 *
 * server.listen(handle[,backlog][,callback]) // object number function
 * The handle object can be set to either a server or socket(anything with an underlying _handle member),or a {fd:&lt;n&gt;} object
 * This will cause the server to accept connections on the specified handle,but it is presumed that the file descriptor or handle has already been bound to a port or domain socket
 * Listening on a file descriptor is not support on windows.
 * This function is asynchronous.when the server has been bound ,&quot;listening&quot; event will be emitted .The last parameter callback will be added as a listener for the &quot;listening&quot; event
 * The parameter backlog behaves the same as in server.listen([port][,hostname][,backlog][,callback])
 * 
 * server.listen(options[,callback])
 * The port,host,and backlog properties of options ,as well as the optional callback function,behave as they on a call to server.listen([port][,hostname][,backlog][,callback])
 * 
 * server.listen(path[,backlog][,callback])
 * Start a local socket server listening for connections on the given path
 * This function is asynchronous.When the server has been bound,&quot;listening&quot; event will be emitted.The last parameter callback will be added as a listener for the &quot;listening&quot; event
 */

/**
 * net.Socket 
 * This object is an abstraction of a TCP or local . net.socket instances implement a duplex Stream interface.They can be created by the user and used as a client(with connec())
 * or they can be created by node.js and passed to the user through the &quot;connection&quot; event of a server
 */

var net = require(&#39;net&#39;)
var server = net.createServer((c)=&gt;{
    console.log(&quot;client connected&quot;)
    c.on(&quot;end&quot;,()=&gt;{
        console.log(&quot;client disconnected&quot;)
    })
    c.write(&quot;hello\r\n&quot;)
    c.pipe(c)
})

server.on(&quot;error&quot;,(err)=&gt;{
    throw err
})

server.listen(3000,()=&gt;{
    console.log(&quot;server bound&quot;)
})
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>