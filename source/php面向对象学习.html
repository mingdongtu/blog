<html>
  <head>
	  	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
    	<title>php面向对象学习</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<h1 id="-">什么是面向对象？</h1>
<blockquote>
<p>面向对象编程是一种计算机编程架构，oop的一条基本原则是计算机程序是由单个能起到子程序作用的单元或对象组合而成，oop达到了软件工程的三个目标：重用性、灵活性和拓展性。为了实现整体运算，每个对象都能接受信息、处理数据和向其他对象发送信息。面向对象一直是软件开发领域内比较热门的话题。</p>
<p>首先，面向对象符合人类看待事物的一般规律</p>
<p>其次，采用面向对象方法可以使系统各部分给司其职、各尽所能，犹如社会分工一样，社会（软件、代码）大发展的必然结果。如此，编程具有更强的重用性。</p>

</blockquote>
<h1 id="-">什么是类，什么是对象，类和对象之间的关系</h1>
<h2 id="-">类的概念</h2>
<p>类是具有相同属性和服务的一组对象的集合。它为属于该类的所有对象提供了统一的抽象描述，其内部包括属性和服务两个主要部分。在面向对象的编程语言中，类是一个独立的程序单位，它应有一个类名并包括属性说明和服务说明两个部分。<br/></p>
<h2 id="-">对象的概念</h2>
<p>对象是系统中用来描述客观事物的一个实体，它是构成系统的一个基本单位。一个对象由一组属性和对这组属性进行操作的一组服务组成。从更抽象的角度来说，对象是问题域或实现域中某些事物的一个抽象，它反应该事物在系统中需要保存的信息和发挥的作用；它是一组属性和有权对这些属性进行操作的一组服务的封装体。客观世界是由对象和对象之间的联系组成。</p>
<h1 id="-">什么是面向对象编程</h1>
<p>就不说他的概念，如果你想建立一个电脑教室，首先要有一个房间， 房间里面要有N台电脑，有N个桌子， N个椅子， 白板， 投影机等等，这些是什么，刚才咱们说了， 这就是对象，能看到的一个个的实体，可以说这个电脑教室的单位就是这一个个的实体对象， 它们共同组成了这个电脑教室，那么我们是做程序，这和面向对象有什么关系呢？开发一个系统程序和建一个电脑教室类似，你把每个独立的功能模块抽象成类形成 对象，由多个对象组成这个系统，这些对象之间都能够接收信息、处理数据和向其它对象发送信息等等相互作用。就构成了面向对象的程序。</p>
<h1 id="-">如何抽象一个类？</h1>
<p>面向对象的单位就是对象，但对象又是通过类的实例化出来的，所以首先要做的就是如何声明类，做出来一个类容易，只要掌握基本的程序语法定义规则就可以做的出来，那么一个项目要用多少个类，用多少个对象，在哪儿定义类，定义一个什么样的类，这个类实例化多少个对象，类里面有多少个属性，有多少个方法等等，这就需要时间的积累了。类的定义：</p>
<pre><code class="lang-php">class 类名 {}
</code></pre>
<p>所用的对象我们用类取描述都是类似的，做出一个类来，从定义的角度分两部分，第一是从静态上描述，第二是从动态上描述，静态上描述就是我们常说的属性，动态则是功能，属性又叫做这个类的成员属性，方法叫做这个额类的成员方法。</p>
<pre><code class="lang-php">class Person{
    成员属性：姓名、性别、年龄、身高、体重、电话、家庭住址；
    成员方法：可以开车， 会说英语， 可以使用电脑；
}
</code></pre>
<h1 id="php-">php中的对象</h1>
<p>一个类可以实例出多个对象，每个对象都是独立的，每个对象都有自己的属性和方法。对象在php里面是一种复合数据，在运行的时候需要加载到内存中。<br/>
内存从逻辑上总体上分为4段：栈空间、堆空间、代码段、初始化静态段，程序里面不同的声明放在不同的内存段里面，栈空间段是存储占用相同空间长度并且占用空间小的数据类型的地方，比如说整型1，10，100，1000，10000等等，在内存里面占用空间是等长的，都是64位4个字节。那么数据长度不定长，而且占有空间很大的数据类型的数据放在内存的哪个片段里面呢？这样的数据是放在堆里面的。栈内存是可以直接存储的，而堆内存是不可以直接存储的内存。对于我们的对象来说，就是一种大的数据类型而且是占用空间不定长的类型，所以说对象是放在堆里面的，但对象名称，所以说对象是放在堆里面的，但对象名称是放在栈里面的，这样就可以通过对象名称就可以使用对象了。</p>
<h1 id="-">如何去使用对象中的成员</h1>
<p>php对象中的成员有两种：一种是成员属性，一种是成员方法。对象我们已经可以实例化了吗，那么如何使用对象的成员呢?要想访问对象中的成员就要使用一个特殊的操作符&quot;-&gt;&quot;来完成对象成员的访问：<br/>
对象-&gt;属性；<br/>
对象-&gt;方法；<br/></p>
<pre><code class="lang-php">class Person {
    // 下面是人的成员属性
    var $name;      // 人的名子
    var $sex;       // 人的性别
    var $age;       // 人的年龄

    // 下面是人的成员方法
    function say() { // 这个人可以说话的方法
        echo &quot;这个人在说话&quot;;
    }

    function run() { // 这个人可以走路的方法
        echo &quot;这个人在走路&quot;;
    }
}
$p1 = new Person(); // 创建实例对象$p1
$p2 = new Person(); // 创建实例对象$p2
$p3 = new Person(); // 创建实例对象$p3
// 下面三行是访问$p2对象的属性
echo &quot;p2对象的名子是：&quot; . $p2-&gt;name;
echo &quot;p2对象的性别是：&quot; . $p2-&gt;sex;
echo &quot;p2对象的年龄是：&quot; . $p2-&gt;age;
// 下面两行访问$p2对象中的方法
$p2-&gt;say();
$p2-&gt;run();
</code></pre>
<h1 id="-this-">特殊的引用&quot;$this&quot;的使用</h1>
<p>通过&quot;对象-&gt;成员&quot;的方式调用对象中的成员，这种方式是在对象的外部访问对象中成员的形式，那如果在对象内部，让对象里的方法访问对象的属性，或是对象中的方法取调用本对象的其它方法时如何解决？因为对象里面的所有的成员需要用对象来调用，包括内部成员之间的调用，在php里面提供的$this是一个对本对象的引用，每个对象里面都有一个对象的引用$this来代表这个对象，完成对象内部成员的调用，this的本意就是&quot;这个&quot;的意思。</p>
<h1 id="-__construct-__destruct-">构造方法<strong>construct()与析构方法</strong>destruct()</h1>
<p>大多数类都有一种称为构造函数的特殊方法。当创建一个对象时，它将自动调用构造函数，也就是使用new这个关键字来实例化对象的时候自动调用构造方法。构造函数的声明与其他操作的声明一样，只是名称必须是__construct()。<br/>
在一个类中只能声明一个构造方法，而是只有在每次创建对象的时候都会取调用一次构造方法，不能主动的调用这个方法，所以通常用它执行一些有用的初始化任务。<br/>
析构函数容许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件，关闭资源（如mysql连接资源），释放结果集合。<br/>
Q：为什么在new Classname();之后会调用析构函数？<br/>
A:其实这个问法就有问题，事实是php页面执行完成之后,内存中就会销毁所有的变量，这个页面创建的对象都会被销毁。<br/></p>
<h1 id="-var-public-protected-private-">封装性（var、public、protected与private的关系）</h1>
<p>封装性是面向对象编程中的三大特性之一，封装性就是把对象的属性和服务结合成一个独立的相同单位，并尽可能隐蔽对象的内部细节，包含两个含义：<br/>
1.把对象的全部属性和全部服务结合在一起，形成一个不可分割的独立单位（即对象）。<br/>
2.把信息隐蔽，即尽可能隐蔽对象的内部细节，对外形成一个边界（或者说性成果一道屏障），只保留有限的对外接口使之与外部发生联系。</p>
<p><hr/>
封装的原则在软件让的反应是：要求使对象以外的部分不能随意存取对象内部数据（属性），从而有效的避免了外部错误对它的“交叉感染”，使软件错误能够局部化，大大减少查错和排除的难度。<br/></p>
<ul>
<li>private,可以把成员封装上，封装上的成员就不能被类外面直接访问了，只有对象内部自己可以访问。</li>
<li>没有加任何访问控制，默认的是public的，任何地方都可以访问。</li>
<li>protected,在类继承的整个原型链上均可访问。</li>
<li>public，均可访问。</li>
</ul>
<h1 id="-">继承</h1>
<p>继承作为面向对象的三个重要特性的一个方面，在面向对象的领域有及其重要的作用。它指建立一个新的派生类，从一个或多个先前定义的类中继承数据和函数，而且可以重新定义或加进新数据和函数，从而建立了类的层次或等级。简单点就是，继承性是子类自动共享父类数据结构和方法机制，这是类之间的一种关系。在定义和实现一个类的时候，可以在一个已经存在的类的基础上来进行，把这个已经存在的类所定义的内容作为自己的内容，并加入若干新的内容。继承也可以叫做拓展。<br/>
通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基类，又称为父类以及超类。由已存在的类派生出的新类称为派生类，又称子类。<br/>
在软件开发中，类的继承性使所建立的软件具有开放性、可拓展性，这是信息组织与分类的行之有效的方法，它简化了对象、类的创建的工作量，增加了代码的可重用性。采用继承性，提供了类的规范的等级结构，通过类的继承关系，使公共特性能够共享，提高了软件重用性。<br/></p>
<h1 id="-">重载新的方法</h1>
<p>在学习PHP 这种语言中你会发现， PHP中的方法是不能重载的， 所谓的方法重载就是定义相同的方法名，通过“参数的个数“不同或“参数的类型“不 同,来访问我们的相同方法名的不同方法。但是因为PHP是弱类型的语言， 所以在方法的参数中本身就可以接收不同类型的数据，又因为PHP的方法可以接收不定个数的参数，所以通过传递不同个数的参数调用不相同方法名的不同方法也是不成立的。所以在PHP里面没有方法重载。不能重载也就是在你的项目中不能定义相同方法名的方法。另外，因为PHP没有名子空间的概念，在同一个页面和被包含的页面中不能定义相同名称的方法， 也不能定义和PHP给我提供的方法的方法重名，当然在同一个类中也不能定义相同名称的方法。<br/></p>
<h1 id="-public-protected-private-">访问类型（public、protected、private）</h1>
<ul>
<li>public 公有修饰符，类中的成员将没有访问限制，所有的外部成员都可以访问（读和写）这个类成员(包括成员属性和成员方法)，如果类的成员没有指定成员访问修饰符，将被视为public;</li>
<li>private 私有修改符，被定义为private的成员，对于同一个类里的所有成员是可见的，即没有访问限制；但对于该类的外部代码是不允许改变甚至读操作，对于该类的子类，也不能访问private修饰的成员;(另外在子类覆盖父类的方法时也要注意一点，子类中方法的访问权限一定不能低于父类被覆盖方法的访问权限，也就是一定要高于或等于父类方法的访问权限。)</li>
</ul>
<h1 id="static-const-">static和const关键字的使用</h1>
<p>static关键字是在类中描述成员属性和成员方法是静态的；静态的成员的好处在哪儿呢？static成员能够限制外部访问，因为static的成员是属于类的，不属于任何对象实例，是在类第一次被加载的时候分配的空间，只对类的实例共享。（个人理解就是减少内存）。在内存的角度，内存从逻辑上被分为四段，其中对象是放在“堆内存”里面，对象的引用被放到了“栈内存”里，而静态成员则放到了“初始化静态段”，在类第一次被加载的时候放入的，可以让堆里面的对象所共享，既然是所有的类都可以共享，那么静态成员就相当于全局变量与全局函数。<br/>
因为静态成员是在类第一次加载的时候就创建的，所以在类的外部需要对象而使用类名就可以访问到静态的成员；静态成员被这个类的每个实例对象所共享，那么我们使用对象是否可以访问类中的静态成员呢？静态的成员不是在每个对象内部存在的，但是每个对象访问成员的话就会出现没有这个属性的定义，使用对象访问不到静态成员。类里面的静态方法只能访问类的静态的属性，在类里面的静态方法是不能访问类的非静态成员的，原因很简单，我们要想在本类的方法中访问本类的其它成员，我们需要使用$this这个引用，而$this这个引用指针是代表调用此方法的对象，我们说了静态的方法是不用对象调用的，而是使用类名来访问， 所以根本就没有对象存在，也就没有$this这个引用了，没有了$this这个引用就不能访问类里面的非静态成员，又因为类里面的静态成员是可以不用对象 来访问的，所以类里面的静态方法只能访问类的静态的属性，即然$this不存在，在静态方法中访其它静态成员我们使用的是一个特殊的类“self”; self和$this相似，只不过self是代表这个静态方法所在的类。所以在静态方法里，可以使用这个方法所在的类的“类名“，也可以使用“self”来访问其它静态成员，如果没有特殊情况的话，我们通常使用后者，即“self::成员属性”的方式。<br/>
const是一个定义常量的关键字，在PHP中定义常量使用的是“define()”这个函数，但是在类里面定义常量使用的是“const”这个关键字。如果在程序中改变了它的值，那么会出现错误，用“const”修饰的成员属性的访问方式和“static”修饰的成员访问的方式差不多，也是使用“类名”，在方法里面使用“self”关键字。但是不用使用“$”符号，也不能使用对象来访问。<br/></p>
<h1 id="-__clone-">克隆对象 __clone()方法</h1>
<p>根据一个对象完全克隆出一个一模一样的对象，使用clone关键字；<strong>clone()方法自动调用的时间，在对象克隆时；如果想在克隆后改变原对象内容，需要在</strong>clone()中重写原本的属性和方法，&#39;__clone()&#39;方法可以没有参数，它自动包含$this和$that两个指针，$this指向复本，而$that指向原本；</p>
<pre><code class="lang-php">$p2 = clone $p1;
class Person {
    // 下面是人的成员属性
    var $name;  // 人的名子
    var $sex;   // 人的性别
    var $age;   // 人的年龄

    // 定义一个构造方法参数为属性姓名$name、性别$sex和年龄$age进行赋值
    function __construct($name = &quot;&quot;, $sex = &quot;&quot;, $age = &quot;&quot;) {
        $this-&gt;name = $name;
        $this-&gt;sex = $sex;
        $this-&gt;age = $age;
    }

    // 这个人可以说话的方法, 说出自己的属性
    function say() {
        echo &quot;我的名子叫：&quot; . $this-&gt;name . &quot; 性别：&quot; . $this-&gt;sex . &quot; 我的年龄是：&quot; . $this-&gt;age . &quot;&lt;br&gt;&quot;;
    }

    // 对象克隆时自动调用的方法, 如果想在克隆后改变原对象的内容，需要在__clone()中重写原本的属性和方法
    function __clone() {
        // $this指的复本p2, 而$that是指向原本p1，这样就在本方法里，改变了复本的属性。
        $this-&gt;name = &quot;我是假的 $that-&gt;name&quot;;
        $this-&gt;age = 30;
    }
}

$p1 = new Person(&quot;张三&quot;, &quot;男&quot;, 20);
$p2 = clone $p1;
$p1-&gt;say();
$p2-&gt;say();
我的名子叫：张三 性别：男 我的年龄是：20
我的名子叫：我是假的张三 性别：男 我的年龄是：30
</code></pre>
<h1 id="__call-">__call()处理调用错误</h1>
<p>在程序开发中，如果在使用对象调用对象内部方法时候，调用的这个方法不存在那么程序就会出错，然后程序退出不能继续执行。那么可不可以在程序调用对象内部 不存在的方法时，提示我们调用的方法及使用的参数不存在，但程序还可以继续执行，这个时候我们就要使用在调用不存在的方法时自动调用的方 法“<strong>call()”。<br/>
“</strong>call()”方法，这个方法有2个参数，第一个参数为调用不存在的方法过程中，自动调用__call()方法时，把这个不存在的方法的方法名传给第一个参数，第二个参数则是把这个方法的多个参数以数组的形式传进来。</p>
<pre><code class="lang-php">/ 这是一个测试的类，里面没有属性和方法
class Test {
    // 调用不存的方法时自动调用的方法，第一个参数为方法名，第二个参数是数组参数
    function __call($function_name, $args) {
        print &quot;你所调用的函数：$function_name(参数：&quot;;
        print_r($args);
        echo &quot;)不存在！&lt;br&gt;&quot;;
    }
}

// 产生一个Test类的对象
$test = new Test();

// 调用对象里不存在的方法
$test-&gt;demo(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);

// 程序不会退出可以执行到这里
echo &quot;this is a test&lt;br&gt;&quot;;

你所调用的函数： demo(参数：Array ( [0] =&gt; one [1] =&gt; two [2] =&gt; three ) )不存在！
this is a test
</code></pre>
<h1 id="-abstract-">抽象方法和抽象类（abstract）</h1>
<p>在oop中，一个类可以有一个或多个子类，而每个类都至少有一个公有的方法做为外部代码访问其的接口。而抽象方法就是为了方便继承而使用的。<br/>
抽象方法，我们在类里面定义的没有具体的方法体的方法就是抽象方法，所谓的没有方法体指的是，在方法声明的时候，没有大括号以及其中的内容，而是直接在声明时在方法名后加上分号结束，另外在声明抽象方法时还要加一个关键字&quot;abstract&quot;来修饰。<br/>
只要一个类里面有一个方法是抽象方法，那么这个类就要定义为抽象类，抽象类也要使用“abstract”关键字来修饰；在抽象类里面可以有不是抽象的方法和成员属性，但只要有一个方法是抽象的方法，这个类就必须声明为抽象类，使用”abstract”来修饰。<br/></p>
<pre><code class="lang-php">abstract function fun1();
abstract function fun2();
</code></pre>
<p>抽象类的特点：不能产生实例对象，所以也不能直接使用。前面我们多次提到过类不能直接使用，我们使用的是通过类实例化出来的对象，那么抽象类不能产生实例对象我们声明抽象类有什么用呢？我们是将抽象方法是做为子类重载的模板使用的，定义抽象类就相当于定义了一种规范，这种规范要求子类去遵守，子类继承抽象类之后，把抽象类里面的抽象方法按 照子类的需要实现。子类必须把父类中的抽象方法全部都实现，否则子类中还存在抽象方法，那么子类还是抽象类，还是不能实例化类；为什么我们非要从抽象类中继承呢？因为有的时候我们要实现一些功能就必须从抽象类中继承，否则这些功能你就实现不了，如果继承了抽象类，就要实现类其中的抽象方法；</p>
<h1 id="php5-interface-">PHP5接口技术（interface）</h1>
<p>接口的思想是指定了一个实现了该接口的类必须实现的一系列方法。接口是一种特殊的抽象类，抽象类又是一种特殊的类，所以接口也是一种特殊的类，为 什么说接口是一种特殊的抽象类呢？如果一个抽象类里面的所有的方法都是抽象方法，那么我们就换一种声明方法使用“接口”；也就是说接口里面所有的方法必须 都是声明为抽象方法，另外接口里面不能声明变量(但可声明常量constant)，而且接口里面所有的成员都是public权限的。所以子类在实现的时候 也一定要使用public权限实限。声明一个类的时候我们使用的关键字是“class”，而接口一种特殊的类，使用的关键字是“interface”;<br/></p>
<h1 id="-">多态的应用</h1>
<p>多态是除封装和继承之外的另一个面象对象的三大特性之一。对于面向对象的程序来说，多态就是把子类对象赋值给父类引用，然后调用父类的方法，去执行子类覆盖父类的那个方法，但在PHP里是弱类型的，对象引用都是一样的不分父类引用，还是子类引用。</p>
<h1 id="-serialize-__sleep-__wakeup-">把对象串行化serialize()方法，<strong>sleep()方法，</strong>wakeup()方法</h1>
<p>有时候需要把一个对象在网络上传输，为了方便传输，可以把整个对象转化为二进制串，等到达另一端时，再还原为原来的对象，这个过程称之为串行化(也叫序列化)。在PHP5中有两个魔术方法<strong>sleep()方法和</strong>wakeup()方法，在对象串行化的时候，会调用一个<strong>sleep()方法来完成一 些睡前的事情；而在重新醒来，即由二进制串重新组成一个对象的时候，则会自动调用PHP的另一个函数</strong>wakeup()，做一些对象醒来就要做的动作。</p>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>